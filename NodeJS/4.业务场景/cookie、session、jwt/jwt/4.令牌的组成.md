# 令牌的组成

## 组成部分

  - 为了保证令牌的安全性，jwt令牌由三个部分组成，分别是：

    1. `header`：令牌头部，记录了整个令牌的类型和签名算法

    2. `payload`：令牌负荷，记录了保存的主体信息，比如你要保存的用户信息就可以放到这里

    3. `signature`：令牌签名，按照头部固定的签名算法对整个令牌进行签名，该签名的作用是：保证令牌不被伪造和篡改

      - 它们组合而成的完整格式是：`header.payload.signature`

      - 比如，一个完整的jwt令牌如下：

        ```javascript
        eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9.BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc
        ```

      - 它各个部分的值分别是：

          - `header：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`

          - `payload：eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9`

          - `signature: BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc`

  - ![](./jwt.png)

## header

  - 它是令牌头部，记录了整个令牌的类型和签名算法

  - Header 部分由 JSON 对象 `{ typ, alg }` 两部分构成，使用 `base64url(header)` 算法转为字符串

    ```json
    {
      "alg":"HS256",
      "typ":"JWT"
    }
    ```

  - 该对象记录了：

      - alg：signature部分使用的签名算法(支持的算法为 `['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none']`)，通常可以取两个值

          - HS256：一种对称加密算法，使用同一个秘钥对signature加密解密

          - RS256：一种非对称加密算法，使用私钥加密，公钥解密

      - typ：整个令牌的类型，固定写 `JWT` 即可

  - 设置好了`header`之后，就可以生成`header`部分了

  - 具体的生成方式及其简单，就是把`header`部分使用`base64 url`编码即可

    > `base64 url`不是一个加密算法，而是一种编码方式，它是在`base64`算法的基础上对 `+` 、 `=` 、 `/` 三个字符做出特殊处理的算法
    >
    > 而`base64`是使用64个可打印字符来表示一个二进制数据，具体的做法参考[百度百科](https://baike.baidu.com/item/base64/8545775?fr=aladdin "百度百科")

    - 浏览器提供了`btoa`函数，可以完成这个操作：

      ```javascript
      window.btoa(JSON.stringify({
        "alg":"HS256",
        "typ":"JWT"
      }))
      // 得到字符串：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
      ```

    - 同样的，浏览器也提供了`atob`函数，可以对其进行解码：

      ```javascript
      window.atob("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9")
      // 得到字符串：{"alg":"HS256","typ":"JWT"}
      ```

    > nodejs中没有提供这两个函数，可以安装第三方库`atob`和`bota`搞定
    >
    > 或者，手动搞定

## payload

  - 这部分是jwt的主体信息，它仍然是一个JSON对象，它可以包含以下内容：

    ```json
    {
      "ss"："发行者",
      "iat"："发布时间",
      "exp"："到期时间",
      "sub"："主题(用途)",
      "aud"："听众",
      "nbf"："在此之前不可用",
      "jti"："JWT ID"
    }
    ```

  - 以上属性可以全写，也可以一个都不写，它只是一个规范，就算写了，也需要你在将来验证这个jwt令牌时手动处理才能发挥作用

  - 上述属性表达的含义分别是：

      - ss：发行该jwt的是谁，可以写公司名字，也可以写服务名称

      - iat：该jwt的发放时间，通常写当前时间的时间戳

      - exp：该jwt的到期时间，通常写时间戳

      - sub：该jwt是用于干嘛的

      - aud：该jwt是发放给哪个终端的，可以是终端类型，也可以是用户名称，随意一点

      - nbf：一个时间点，在该时间点到达之前，这个令牌是不可用的

      - jti：jwt的唯一编号，设置此项的目的，主要是为了防止重放攻击（重放攻击是在某些场景下，用户使用之前的令牌发送到服务器，被服务器正确的识别，从而导致不可预期的行为发生）

  - 可是到现在，看了半天，没有出现我想要写入的数据啊😂

  - 当用户登陆成功之后，我可能需要把用户的一些信息写入到jwt令牌中，比如用户id、账号等等（密码就算了😳）

  - 其实很简单，payload这一部分只是一个json对象而已，你可以向对象中加入任何想要加入的信息

  - 比如，下面的json对象仍然是一个有效的 `payload`

    ```json
    {
      "foo":"bar",
      "iat":1587548215
    }
    ```

  - `foo: bar` 是我们自定义的信息，`iat: 1587548215` 是jwt规范中的信息

  - 最终，payload部分和header一样，需要通过`base64 url`编码得到：

    ```javascript
    window.btoa(JSON.stringify({
      "foo":"bar",
      "iat":1587548215
    }))
    // 得到字符串：eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9
    ```

## signature

  - 这一部分是jwt的签名，正是它的存在，保证了整个jwt不被篡改

  - 这部分的生成，是对前面两个部分的编码结果，按照头部指定的方式进行加密

  - 比如：头部指定的加密方法是 `HS256` ，前面两部分的编码结果是`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9`

  - 则第三部分就是用对称加密算法 `HS256` 对字符串 `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9` 进行加密，当然你得指定一个秘钥，比如 `shhhhh`

    ```javascript
    // 伪代码
    HS256(`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9`, "shhhhh")
    // 得到：BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc
    ```

  - 最终，将三部分组合在一起，就得到了完整的jwt

    ```javascript
    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9.BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc
    ```

  - 由于签名使用的秘钥保存在服务器，这样一来，客户端就无法伪造出签名，因为它拿不到秘钥。

  - 换句话说，之所以说无法伪造jwt，就是因为第三部分的存在。

  - 而前面两部分并没有加密，只是一个编码结果而已，可以认为几乎是明文传输

    > 这不会造成太大的问题，因为既然用户登陆成功了，它当然有权力查看自己的用户信息
    > &#x20;  &#x20;
    > &#x20;   甚至在某些网站，用户的基本信息可以被任何人查看
    > &#x20;  &#x20;
    > &#x20;   你要保证的，是不要把敏感的信息存放到jwt中，比如密码

  - jwt的 `signature` 可以保证令牌不被伪造，那如何保证令牌不被篡改呢？

  - 比如，某个用户登陆成功了，获得了jwt，但他人为的篡改了`payload`，比如把自己的账户余额修改为原来的两倍，然后重新编码出 `payload` 发送到服务器，服务器如何得知这些信息被篡改过了呢？

  - 这就要说到令牌的验证了
