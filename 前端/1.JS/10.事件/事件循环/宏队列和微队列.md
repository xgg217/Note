# 宏队列和微队列

## 宏队列和微队列 执行

  - 当执行栈清空时，JS 引擎首先会将微任务中的所有任务一次执行结束，如果没有微任务，则执行宏任务。

## 宏队列 macrotask

  - `macrotask` 可称为 `task`

  - 每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）

  - 每一个 `task` 会从头到尾将这个任务执行完毕，不会执行其它

  - 浏览器为了能够使得JS内部 `task` 与 `DOM` 任务能够有序的执行，会在一个 `task` 执行结束后，在下一个 `task` 执行开始前，**对页面进行重新渲染** （task->渲染->task->...）

  - 场景：主代码块、计时器、AJAX请求、 DOM事件

## 微队列 microtask

  - `microtask` 称为 `jobs`

  - 可以理解是在当前 `task` 执行结束后立即执行的任务

  - 在当前task任务后，下一个task之前，**在渲染之前**

  - 所以它的响应速度相比 `setTimeout`（`setTimeout` 是 `task` ）会更快，因为无需等渲染

  - 也就是说，在某一个 `macrotask` 执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）

  - 场景： `Promise.then` 、 `MutationObserver` (可以用来实现 `microtask`，优先级小于 `Promise`， 一般是 `Promise` 不支持时才会这样做) 、 `process.nextTick`

## 补充说明

  - 在node环境下，`process.nextTick` 的优先级高于 `Promise`

  - 即在宏任务结束后会先执行微任务队列中的 `nextTickQueue` 部分，然后才会执行微任务中的 `Promise` 部分。

## 线程解释

  - `macrotask`(宏队列) 中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护

  - `microtask` (微队列) 中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前 `macrotask` 执行完毕后执行，而这个队列由JS引擎线程维护

（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）

## 总结

  - 执行一个宏任务（栈中没有就从事件队列中获取）

  - 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中

  - 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）

  - 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染

  - 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
