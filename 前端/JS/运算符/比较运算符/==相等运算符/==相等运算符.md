# ==相等运算符

## 基础

*   相等运算符比较相同类型的数据时，与严格相等运算符完全一样

*   比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较

## 比较之原始类型

*   原始类型的数据会转换成数值类型再进行比较

    ```javascript
    1 == true // true
    // 等同于 1 === 1

    0 == false // true
    // 等同于 0 === 0

    2 == true // false
    // 等同于 2 === 1

    2 == false // false
    // 等同于 2 === 0


    ```

    ```javascript
    'true' == true // false
    // 等同于 Number('true') === Number(true)
    // 等同于 NaN === 1

    '' == 0 // true
    // 等同于 Number('') === 0
    // 等同于 0 === 0

    '' == false  // true
    // 等同于 Number('') === Number(false)
    // 等同于 0 === 0

    '1' == true  // true
    // 等同于 Number('1') === Number(true)
    // 等同于 1 === 1

    '\n  123  \t' == 123 // true
    // 因为字符串转为数字时，省略前置和后置的空格
    ```

## 比较之对象与原始值

*   对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较

    ```javascript
    [1] == 1 // true
    // 等同于 Number([1]) == 1

    [1] == '1' // true
    // 等同于 String([1]) == Number('1')

    [1] == true // true
    // 等同于 Number([1]) == Number(true)
    ```

## 注意

*   `undefined` 和 `null`

    *   `undefined` 和 `null` 与其他类型的值比较时，结果都为 `false`，它们互相比较时结果为 `true`

        ```javascript
        false == null // false
        false == undefined // false

        0 == null // false
        0 == undefined // false

        undefined == null // true
        ```

    *   绝大多数情况下，对象与 `undefined` 与 `null` 比较，都返回 `false`

    *   只有在对象转为原始值得到 `undefined` 时，才会返回 `true`，这种情况是非常罕见的

## ==缺点

*   相等运算符隐藏的类型转换，会带来一些违反直觉的结果

    ```javascript
    '' == '0'           // false
    0 == ''             // true
    0 == '0'            // true

    2 == true           // false
    2 == false          // false

    false == 'false'    // false
    false == '0'        // true

    false == undefined  // false
    false == null       // false
    null == undefined   // true

    ' \t\r\n ' == 0     // true
    ```

*   上面这些表达式都很容易出错，因此不要使用相等运算符（`==`），最好只使用严格相等运算符（`===`）
