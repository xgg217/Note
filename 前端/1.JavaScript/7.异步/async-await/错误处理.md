# 错误处理

## 第一种：捕捉整个async/await函数的错误

  - 这种方式可以捕捉整个 `charCountAdd` 运行过程中出现的错误，错误可能是由 `charCountAdd` 本身产生的，也可能是由对 `data1` 的计算中或 `data2` 的计算中产生的

    ```js
    function charCount(data) {
      return new Promise((resolve, reject) => {
          setTimeout(() => {
              resolve(data.length);
          }, 1000);
      });
    }

    async function charCountAdd(data1, data2) {
      const d1=await charCount(data1);
      const d2=await charCount(data2);
      return d1+d2;
    }
    charCountAdd('Hello','Hi')
        .then(console.log)
        .catch(console.log);//捕捉整个async/await函数的错误
    ...
    ```

## 第二种：捕捉单个的await表达式的错误

  - 通过这种方式可以捕捉每一个 `await` 表达式的错误，如果既要捕捉每一个 `await` 表达式的错误，又要捕捉整个 `charCountAdd` 函数的错误，可以在调用 `charCountAdd` 的时候加个 `catch`

    ```js
    async function charCountAdd(data1, data2) {
      const d1=await charCount(data1)
          .catch(e=>console.log('d1 is null'));
      const d2=await charCount(data2)
          .catch(e=>console.log('d2 is null'));
      return d1+d2;
    }
    charCountAdd('Hello','Hi')
      .then(console.log)
      .catch(console.log);//捕捉整个async/await函数的错误;
    ```

## 第三种：同时捕捉多个的await表达式的错误

  - 代码

    ```js
    async function charCountAdd(data1, data2) {
      let d1,d2;
      try {
        d1=await charCount(data1);
        d2=await charCount(data2);
      }catch (e){
        console.log('d1 is null');
      }
      return d1+d2;
    }
    charCountAdd('Hello','Hi')
      .then(console.log);

    function charCount(data) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve(data.length);
        }, 1000);
      });
    }
    ```

## 捕获多个错误并做不同的处理

  - 示例

    ```js
    async function asyncTask(cb) {
      try {
         const user = await UserModel.findById(1);
         if(!user) return cb('No user found');
      } catch(e) {
          return cb('Unexpected error occurred');
      }

      try {
         const savedTask = await TaskModel({userId: user.id, name: 'Demo Task'});
      } catch(e) {
          return cb('Error occurred while saving task');
      }

      if(user.notificationsEnabled) {
          try {
              await NotificationService.sendNotification(user.id, 'Task Created');
          } catch(e) {
              return cb('Error while sending notification');
          }
      }

      if(savedTask.assignedUser.id !== user.id) {
          try {
              await NotificationService.sendNotification(savedTask.assignedUser.id, 'Task was created for you');
          } catch(e) {
              return cb('Error while sending notification');
          }
      }

      cb(null, savedTask);
    }
    ```

  - 解决办法：可以给 `await` 后的 `promise` 对象添加 `catch` 函数，为此我们需要写一个 `helper`:

    ```js
    // to.js
    export default function to(promise) {
      return promise.then(data => {
          return [null, data];
      })
      .catch(err => [err]);
    }
    ```

    ```js
    import to from './to.js';

    async function asyncTask() {
      let err, user, savedTask;

      [err, user] = await to(UserModel.findById(1));
      if(!user) throw new CustomerError('No user found');

      [err, savedTask] = await to(TaskModel({userId: user.id, name: 'Demo Task'}));
      if(err) throw new CustomError('Error occurred while saving task');

      if(user.notificationsEnabled) {
        const [err] = await to(NotificationService.sendNotification(user.id, 'Task Created'));
        if (err) console.error('Just log the error and continue flow');
      }
    }
    ```
