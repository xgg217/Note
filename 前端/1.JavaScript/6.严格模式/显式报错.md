# 显式报错

## 只读属性不可写

- 赋值：严格模式下，设置字符串的 `length` 属性，会报错。因为 `length` 是只读属性

    ```js
    // 设置只读属性
    'use strict';
    'abc'.length = 5;
    // TypeError: Cannot assign to read only property 'length' of string 'abc'
    ```

    ```js
    // 只读属性
    var str = Object('abc');
    Object.getOwnPropertyDescriptor(str, 'length')
    // Object {
    //   value: 3,
    //   writable: false,
    //   enumerable: false,
    //   configurable: false
    // }
    ```

- 删除：严格模式下，删除不可配置（nonconfigurable）属性都会报错

    ```js
    // 对只读属性赋值会报错
    'use strict';
    var o = {};

    Object.defineProperty(o, 'a', {
      value: 37,
      writable: false
    });

    o.a = 123;
    // TypeError: Cannot assign to read only property 'a' of object #<Object>

    // 删除不可配置的属性会报错
    'use strict';
    var o = Object.defineProperty({}, 'p', {
      value: 1,
      configurable: false
    });

    delete o.p
    // TypeError: Cannot delete property 'p' of #<Object>
    ```

## 只设置了赋值器的属性不可写

- 严格模式下，对一个只设置了赋值器（getter）的属性赋值，会报错

    ```js
    'use strict';

    var o = {
      get v() { return 1; }
    };

    o.v = 2; // 报错
    ```

## 禁止扩展的对象不可扩展

- 严格模式下，对禁止扩展的对象添加新属性，会报错

    ```js
    'use strict';

    var o = {};
    Object.preventExtensions(o);
    o.v = 1; // 报错
    ```

## eval、arguments不可用作标识名

- 严格模式下，使用 `eval` 或者 `arguments` 作为标识名，将会报错

    ```js
    'use strict';
    var eval = 17;
    var arguments = 17;
    var obj = { set p(arguments) { } };
    try { } catch (arguments) { }
    function x(eval) { }
    function arguments() { }
    var y = function eval() { };
    var f = new Function('arguments', "'use strict'; return 17;");
    // SyntaxError: Unexpected eval or arguments in strict mode
    ```

## 函数不能有重名的参数

- 正常模式下，如果函数有多个重名的参数，可以用 `arguments[i]` 读取。严格模式下，这属于语法错误

    ```js
    function f(a, a, b) { // 语法错误
      'use strict';
      return a + b;
    }
    ```
