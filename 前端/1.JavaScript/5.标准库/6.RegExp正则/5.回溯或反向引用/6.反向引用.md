# 反向引用

## 概述

  - 在正则表达式中，使用某个捕获组

  - `\捕获组编号`

    ```js
    const reg = /(\d{2})\1/g;

    console.log(reg.test("1313")); // true
    console.log(reg.test("1312")); // false
    ```

## \1

  - `\1` 反向引用第一次子表达式的引用

    ```js
    const str = 'bbaaaaccddddccccsdffff';
    const reg = /(\w)\1\1\1/g;
    console.log(str.match(reg)); // [ 'aaaa', 'dddd', 'cccc', 'ffff' ]
    ```

    ```js
    const str = 'aabbccddddddcceevv';
    const reg = /(\w)\1(\w)\2/g;
    console.log(str.match(reg)); // [ 'aabb', 'ccdd', 'dddd', 'ccee' ]
    ```

    ```js
    // 将 aabb 转换成 bbaa
    const str = 'aabb';
    const reg = /(\w)\1(\w)\2/g;

    console.log(str.replace(reg, '$2$2$1$1')); // bbaa
    ```

## 示例

  - 示例1：找出连续重复的字母

    ```js
    const str = "aaaaadfddddsaffffeee";
    const reg = /(\w)\1+/g;
    let result = [];
    while(result = reg.exec(str)) {
      console.log(result);
    }
    // [ "aaaaa", "a" ]
    // [ "dddd", "d" ]
    // [ "ffff", "f" ]
    // [ "eee", "e" ]
    ```

  - 示例2：配备 aabb 样式数据

      - `\1` 表示引用第一个子表达式配备的内容, `\2` 表示引用第二个子表达式配备的内容

    ```js
    const str = 'abab';
    const reg = /(\w)\1(\w)\2/g;

    console.log(reg.exec(str)) // [ 'aabb', 'a', 'b', index: 0, input: 'aabbabcd' ]
    console.log(str.match(reg)); // [ 'aabb' ]
    ```

    ```js
    const str = 'aaaa';
    const reg = /(\a)\1/g;

    console.log(reg.exec(str)) // [ 'aa', 'a', index: 0, input: 'aaaa' ]
    console.log(str.match(reg)); // [ 'aa', 'aa' ]
    ```
