# 基础

## 概述

- 可以代理所有内容（原始值，对象和代理对象等）

- 返回值：`{value: ...}`

- 对 `.value` 的访问是响应式的

## 基本使用

- 和响应式对象的 property 类似，ref 的 `.value` property 也是响应式的。同时，当值为对象类型时，会用 `reactive()` 自动转换它的 `.value`

- 一个包含对象类型值的 ref 可以响应式地替换整个对象

    ```js
    const objectRef = ref({ count: 0 })

    // 这是响应式的替换
    objectRef.value = { count: 1 }
    ```

- 一言以蔽之，`ref()` 使我们能创造一种任意值的 “引用” 并能够不丢失响应性地随意传递。这个功能非常重要，因为它经常用于将逻辑提取到 [组合函数](https://staging-cn.vuejs.org/guide/reusability/composables.html "组合函数") 中

## 对象

- 如果给 `value` 的值是一个对象，则会通过 `reactive` 函数进行代理

    ```js
    // 定义
    const info = ref({
      name: '',
      age: '',
    });

    // 修改
    info.value.name = '张三';

    ```

## 解构

- ref 被传递给函数或是从一般对象上被解构时，不会丢失响应性

    ```typescript
    const obj = {
      foo: ref(1),
      bar: ref(2)
    }

    // 该函数接收一个 ref
    // 需要通过 .value 取值
    // 但它会保持响应性
    callSomeFunction(obj.foo)

    // 仍然是响应式的
    const { foo, bar } = obj
    ```

## \#

1. 如果已经是代理，则直接使用代理

    ```js
    import { reactive, readonly, ref } from "vue";

    const state = reactive({a:1, b:2});
    const count = ref(state);

    console.log(state === count.value); // true
    ```
