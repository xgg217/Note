# 对比更新

## 对比过程

*   将新产生的节点，对比之前虚拟 DOM 中的节点，发现差异，完成更新

## 然后对比之前 DOM 树中的那个节点

*   React 为了提交对比效率做出如下假设：

    1.  假设节点不会出现层次的移动（对比时，直接找到旧树中对应位置的节点进行对比

    2.  不同的节点类型会生成不同的结构

    3.  多个兄弟节点通过唯一标识（`key`）来确定对比的新节点

## 是否找到对比目标

*   找到了对比目标

    1.  判断节点类型**是否一致**

        1.  相同的的节点类型

            1.  节点本身类型相同

            2.  如果是由 React 元素生成，`type` 值还必须一致

        2.  其他的都属于不相同的节点类型

*   没有找到对比目标

*   创建新加入的节点

*   卸载多余的旧节点

## 节点类型是否一致

1.  节点类型一样：根据不同的节点类型，做不同的事情

    1.  空节点：不做任何事情

    2.  DOM 节点：直接使用之前 DOM 对象

        1.  直接重用之前的真实 DOM 对象

        2.  将其属性变化记录下来，以待将来统一完成更新（现在还不会真正的变化）

        3.  遍历新的 React 元素的子元素，**递归对比更新**

    3.  文本节点：直接重用之前真实的 DOM 对象。将其属性变化记录下来，以待将来统一完成更新（现在还不会真正的变化）

    4.  函数组件：直接重新调用函数，得到一个节点对象，进入，对比**递归对比更新**

    5.  类组件

        1.  重用之前的组件实例

        2.  调用生命周期方法 `static getDerivedStateFromProps`

        3.  调用生命周期方法 `shouldComponentUpdate`，如果该函数返回 `false`，终止当前流程

        4.  运行 `render` 函数，得到一个**新的节点**，进入新的节点的**对比更新**

        5.  将生命周期函数 `getSnapshotBeforeUpdate` 加入执行队列中，以待将来执行

        6.  将生命周期函数 `componentDidUpdate` 加入执行队列，以待将来执行

    6.  数组节点：遍历数组，进行**递归对比更新**

2.  节点类型不一样

    1.  整体上，卸载旧的节点，创建新的节点

    2.  如果是**文本节点**、**DOM 节点**、 **数组节点**、**空节点**、**函数组件节点**：直接放弃该节点，如果节点有子节点，递归卸载节点

    3.  如果是**类组件节点**：

        1.  直接放弃该节点

        2.  调用用该节点的 `componentWillUnmount` 函数

        3.  递归卸载子节点（先卸载父节点，再卸载子节点）

## 卸载与挂载

1.  创建新节点

2.  卸载旧节
