# 指令1

## 重点

+ 指令前面必须使用 `yield`，以确保该指令的返回结果被 `sage` 控制

## take 指令 -- 阻塞

+ 作用：**阻塞**监听某个 `action`，如果 `action` 发生了变化，则会进行下一步处理

+ `take` 指令 仅监听一次

+ `yield` 得到的是完整的 `action` 对象

    ```js
    import { take } from "redux-saga/effects";
    import { ADD } from "redux/action/counter/index"

    // 只监听一次
    export default function*() {
      console.log("sage 启动");
      const action = yield take(ADD);
      console.log("add 触发了", action);
    }

    // 一直监听
    export default function*() {
      console.log("sage 启动");

      while(true) {
        const action = yield take(ADD);
        console.log("add 触发了", action);
      }
    }
    ```

## all 指令 -- 阻塞

+ 作用: **阻塞** 该函数传入一个数组，数组中放入生成器，`sage` 会等待所有的生成器全部完成后，才会进一步处理

    ```js
    // counterTask.js
    import { take, all } from "redux-saga/effects";
    import { ADD, ASYNCADD } from "redux/action/counter/index";

    export default function* () {
      while(true) {
        const action = yield take(ASYNCADD);
        console.log("异步 add 触发了", action);
      }
    }
    ```

    ```js
    // 合并
    import { take, all } from "redux-saga/effects";
    import counterTask from "./counterTask";
    import aaa from "./aaTask";

    /**
    * sage 任务
    */
    export default function*() {
      yield all([counterTask(), aaa()])
      console.log("完成");
    }
    ```

## takeEvery 指令

+ 作用：不断的监听某个 `action`，当某个 `action` 到达之后，运行一个函数

+ `takeEvery` 永远不会结束当前的生成器&#x20;

    ```js
    import { take,   } from "redux-saga/effects";
    import { ADD, ASYNCADD, ASYNCDEL } from "redux/action/counter/index";

    function* addTask() {
      console.log('addTask 1');
    }

    function* delTask() {
      console.log('delTask 1');
    }

    export default function* () {
      yield takeEvery(ASYNCADD, addTask);
      yield takeEvery(ASYNCDEL, delTask);
      console.log('function  **** ');
    }
    ```

## delay 指令 -- 阻塞

+ 作用：阻塞指定的毫秒数

    ```js
    import { takeEvery, delay  } from "redux-saga/effects";
    import { ASYNCADD } from "redux/action/counter/index";

    function* addTask() {
      yield delay(2000)
      console.log('addTask 11'); // 2000 ms 后触发
    }

    export default function* () {
      yield takeEvery(ASYNCADD, addTask);
      console.log('function  **** ');
    }
    ```

## put 指令

+ 用于重新触发 `action`

+ 相当于 `dispatch` 一个 `action`

    ```js
    import { takeEvery, delay  } from "redux-saga/effects";
    import { ASYNCADD } from "redux/action/counter/index";
    import { getAddAction } from "redux/action/counter/index";

    function* addTask() {
      yield delay(2000)
      console.log('addTask 11'); // 2000 ms 后触发
      yield put(getAddAction()) // 触发新的 action
    }

    export default function* () {
      yield takeEvery(ASYNCADD, addTask);
      console.log('function  **** ');
    }
    ```

## call 指令 -- 可能阻塞

+ 用于副作用（通常是异步）函数调用

+ 可能阻塞（`Promise` 就阻塞）

+ 语法1：`call(fn, ...args)`

+ 语法2：`call([context, fn], ...args)`。`context`: `this` 指向

+ 语法3：`call([context, fnName], ...args)`

    ```js
    import { takeEvery, put, call,  } from "redux-saga/effects";
    import { ASYNCDEL } from "redux/action/counter/index";
    import { getAddAction, getAsyncDelAction } from "redux/action/counter/index";

    function setTime () {
      return new Promise((res, rej) => {
        setTimeout(() => {
          res("计时器触发了");
        }, 2000);
      })
    }

    function* delTask() {
      console.log('delTask 1');
      try {
        const res = yield call(setTime);
        console.log(res);
        yield put(getAddAction())
      } catch (error) {
        // error 表示 rej 的内容
        console.log(error);
      }
    }

    export default function* () {
      console.log(121212);
      yield takeEvery(ASYNCDEL, delTask);
      console.log('function  **** ');
    }
    ```

## apply 指令 -- 可能阻塞

+ 于 `call` 功能类似

+ 用于副作用（通常是异步）函数调用

+ 语法：`apply(context, fn, [args])`

+ `context`: `this` 指向

## select 指令

+ 用于得到当前仓库中的数据

    ```js
    import { select  } from "redux-saga/effects";
    const state = yield select(); // 得到当前仓库的数据
    ```

## cps 指令 -- 可能阻塞

+ 用于调用那些传统的回调方式的异步
