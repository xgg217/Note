# 绑定与修改

## 重点

- `this.props` 和 `this.state`  **可能** 是异步更新的

- 每当使用 `this.setState()` 修改状态时，将再次调用 `render( )` 函数来更改UI中组件的输出

## 什么情况下是同步， 什么情况是异步 ？

- 如果改变状态的代码处于某个 HTML 元素的事件中，则是异步，否则是同步

- 在开发中始终当成异步进行处理

## 获取数据

- `this.seate.key`

- 代码

    ```react&#x20;jsx
    class Home extends Component {
      constructor (props) {
        super(props);
        this.state = {
          name: '张三',
          title: 'title 123',
        };
      }

      run() {
        console.log(this.state.name);
      }

      render() {
        return (
          <>
            <button onClick={this.run.bind(this)}>点击事件456</button>
          </>
        );
      }
    };
    ```

## 传入对象的方式 设置数据

- 不能直接改变状态：因为 React 无法监控到状态发送变化

- 调用 `setState` 后，页面会重新渲染

- 传入对象：`this.setState({key: value});`。相当于把当前的对象与之前的对象进行混合( `Object.assign` )，把当前的数据覆盖之前的数据

    ```js
    this.setState({
      inpValue: value
    })
    ```

    ```react&#x20;jsx
    // 相当于
    Object.assign(this.state, inpValue);
    ```

- 先 调用 `setState`，接着 触发 `render 函数`，最后调用第二个参数

    ```react&#x20;jsx
    // 如果需要立即获取改变后的值，可以使用第二个参数
        this.setState({
          inpValue: value
        }, () => {
            // 先 调用 `setState`，接着 触发 `render 函数`，最后这个回调函数
            console.log(this.state.inpValue)
        })
    ```

## 使用函数 方式 设置数据--推荐使用

- 代码

    ```js
    this.setState((state, props) => {
      timesVisited: state.timesVisited + props.count
    }, () => {
        console.log()
    });
    ```

## 修改数据的方法

1. 直接修改变量的值（**不推荐**）

    ```js
     var player = {score: 1, name: 'Jeff'};
     player.score = 2;
     // player 修改后的值为 {score: 2, name: 'Jeff'}
    ```

2. 使用新的一份数据替换旧数据。（**推荐**）

    ```js
    var player = {score: 1, name: 'Jeff'};

    // 方式1
    var newPlayer = Object.assign({}, player, {score: 2});
    // player 的值没有改变, 但是 newPlayer 的值是 {score: 2, name: 'Jeff'}

    // 方式2
    // 使用对象展开语法，就可以写成：
    var newPlayer = {...player, score: 2};
    ```

## 修改数组

- 不要直接修改数组，可以通过 `.slice()` 方法创建了数组的一个副本，而不是直接修改现有的数组

    ```js
    const squares = this.state.squares.slice();
    ```

- ES6

    ```js
    const squares = [...this.state.squares];
    ```

## 修改对象

- Object.assign

    ```js
    var player = {score: 1, name: 'Jeff'};

    var newPlayer = Object.assign({}, player, {score: 2});
    // player 的值没有改变, 但是 newPlayer 的值是 {score: 2, name: 'Jeff'}
    ```

- 对象展开语法

    ```js
    var player = {score: 1, name: 'Jeff'};

    // 使用对象展开语法，就可以写成：
    var newPlayer = {...player, score: 2};
     // player 的值没有改变, 但是 newPlayer 的值是 {score: 2, name: 'Jeff'}
    ```

## 新数据替换旧数据 好处

- 简化复杂的功能

- 跟踪数据的改变

  - 如果直接修改数据，那么就很难跟踪到数据的改变。跟踪数据的改变需要可变对象可以与之改变之前的版本进行对比，这样整个对象树都需要被遍历一次

  - 跟踪不可变数据的变化相对来说就容易多了。如果发现对象变成了一个新对象，那么我们就可以说对象发生改变了

- 确定在 React 中何时重新渲染

  - 不可变性最主要的优势在于它可以帮助我们在 React 中创建 `pure components`

  - 我们可以很轻松的确定不可变数据是否发生了改变，从而确定何时对组件进行重新渲染
