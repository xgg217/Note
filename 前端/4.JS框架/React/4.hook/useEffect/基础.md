# 基础

## 作用

  - 用于在函数组件中处理副作用

## Effect Hook 执行时间

  - `useEffect` 会在每次渲染后都执行。默认情况下，它在第一次渲染之后和每次更新之后都会执行

  - React 保证了每次运行 `effect` 的同时，DOM 都已经更新完毕

## 副作用操作

  - ajax 请求

  - 计时器

  - 其他异步操作

  - 更改真实 DOM 对象

  - 本地存储

  - 其他会对外部产生影响的操作

## useEffect

  - 接受一个函数作为参数（第一个参数），接受的函数就是需要进行副作用操作的函数

    ```js
    export default function App() {
      const [n, setN] = useState(0);

      const add = (val) => {
        setN(n + val);
      }

      // 副作用代码
      useEffect(() => {
        document.title = `计数器 ${ n }`
      });

      return (
        <div>
          { n }
          <button onClick={ () => add(2) }>+1</button>
        </div>
      )
    }
    ```

  - 第二个参数是数组（可选参数）

      - 数组中记录该副作用的依赖数据

      - 当组件重新渲染后，只有依赖数据与上一次不一样的时，才会执行副作用

      - 当传递依赖数据后，如果数据没有发生变化

        1.  副作用函数仅在第一次渲染后运行

        2.  清理函数仅在卸载组件后运行

    ```js
    useEffect(() => {
      const a = props.left + 1;
      const b = props.top + 1;
      document.title = `计数器 ${ n }`
    },[props.left, props.top]);
    ```

    ```js
    // 仅在组件第一次和卸载时运行
    useEffect(() => {
      console.log('副作用函数，仅在挂载时运行一次');
      return () => {
        console.log('清理函数，仅在卸载时运行一次')
      }
    }, []);
    // 依赖数据为 []，表示不依赖所有数据
    ```

## 细节

  - `useEffect` 函数运行的时间点，是在页面完成真实的 UI 渲染结束后

      - 与类组件中 `componentDidMount` 和 `componentDidUpadate` 是更改了真实 DOM，但是用户还没有看到 UI 更新

      - `useEffect` 中的副作用函数，更改了真实 DOM，并且用户已经看到了 UI 更新，执行是异步的，不会阻塞浏览器

  - 不要将 `useEffect` 函数放入 **判断** 或 **循环** 等代码块中

  - 可以多次使用 `useEffect`

  - `useEffect` 函数可以有返回值，返回值必须是一个函数，该函数叫做清理函数

      - 该函数运行时间点：在每次运行副作用函数之前

      - 首次渲染不会运行

      - 组件被销毁时，一定会运行

        ```js
        useEffect(() => {
          // ***
          return () => {
            // ***
          };
        });
        ```

  - 副作用函数中，如果使用了函数上下文的变量，则由于闭包的影响，会导致副作用函数中变量不会实时变化

  - 副作用函数在每次注册时，会覆盖之前的副作用函数，因此尽量保持副作用函数稳定，否则控制起来比较复杂
