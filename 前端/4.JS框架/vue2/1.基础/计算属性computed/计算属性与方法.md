# 计算属性与方法

## 计算属性 与 方法区别

  - 当使用方法时，每一次页面重新渲染，对应的方法都会重新执行一次

    ```js
    <div id="app">
      <p>{{ name }}</p>
      <p>{{ reversedMsg() }}</p>
    </div>
    ```

    ```js
    data() {
      return {
        msg: 'Hello',
        name: 'shanshan'
      }
    },

    methods: {
      reversedMsg: function () {
        console.log('方法执行啦');
        return this.msg.split('').reverse().join('');
      }
    }
    ```

  - 一旦更改name的值，页面会重新渲染，此刻控制台中打印出方法执行啦这串字符串，代表着reversedMsg这个函数执行了，但是我们并不需要该方法执行，因为改动的数据和这个函数没有任何关系，如果这个函数内的逻辑很复杂，那么对于性能来讲，也是一种消耗

  - 但是利用计算属性做，就不会有这样的现象出现，如：

    ```js
    data() {
      return {
        msg: 'Hello',
        name: 'shanshan'
      }
    },

    computed: {
      reversedMsg: function () {
        console.log('计算执行啦');
        return this.msg.split('').reverse().join('');
      }
    }
    ```

  - 此时可以看到，当给数据name重新赋值时，计算属性并没有执行

  - 所以，计算属性和方法的**最本质的区别**，是：计算属性是基于响应式依赖进行缓存的，计算属性的值一直存于缓存中，只要它依赖的data数据不改变，每次访问计算属性，都会立刻返回缓存的结果，而不是再次执行函数。而方法则是每次触发重新渲染，调用方法将总会再次执行函数

## 为什么需要缓存

  - 假如说，我们有一个计算属性A，它需要遍历一个巨大的数组并且做巨大的计算

  - 然后我们需要使用到这个计算属性A，如果没有缓存，我们就会再次执行A的函数，这样性能开销就变得很大了
