# 基础

## 基础

  - 更改 `Vue` 的 `store` 中的状态的唯一方法是提交 `mutation`

    ```js
    const store = new Vuex.Store({
      state: {
        count: 1
      },
      mutations: {
        increment (state) {
          // 变更状态
          state.count++
        }
      }
    })
    ```

  - **不能直接**调用一个mutation handler

  - 这个选项更像是事件注册： **“当触发一个类型为**\*\*  的\*\*​**时，调用次函数。”：**

    ```js
    this.$store.commit('increment');
    ```

## 提交载荷（Payload）

  - 你可以向 `store.commit` 传入额外的参数，即 `mutation` 的载荷（`payload`）：

    ```js
    mutations: {
      increment (state, n) {
        state.count += n
      }
    }
    ```

    ```js
    store.commit('increment', 10)
    ```

  - 在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 `mutation` 会更易读：

## 对象风格的提交方式

  - 提交 mutation 的另一种方式是直接使用包含 type 属性的对象：

    ```js
    store.commit({
      type: 'increment',
      amount: 10
    })
    ```

  - 当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：

    ```js
    mutations: {
      increment (state, payload) {
        state.count += payload.amount
      }
    }
    ```

## 使用常量替代 Mutation 事件类型

  - 把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：

    ```js
    // mutation-types.js
    export const COUNT_INCREMENT = 'COUNT_INCREMENT'
    ```

    ```js
    // store.js
    import Vuex from 'vuex'
    import { COUNT_INCREMENT } from './mutation-types'

    const store = new Vuex.Store({
      state: { ... },
      mutations: {
        [COUNT_INCREMENT] (state) {
          // ...
        }
      }
    })
    ```

    ```js
    // 组件
    import { COUNT_INCREMENT } from '@/store/mutation-types'
    ```

  - 用不用常量取决于自己，在需要多人协作的大型项目中，这会很有帮助
