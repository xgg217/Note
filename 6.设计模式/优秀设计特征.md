# 优秀设计特征

## 特征1 代码复用

+ 无论是开发何种软件产品，成本和时间都最重要的两个维度：

  + 较短的开发时间意味着可比竞争对手更早进入市场
  + 较低的开发成本意味着能够留出更多营销资金，因此能更广泛地覆盖潜在客户

+ 代码复用是减少开发成本时最常用的方式之一
+ 其意图非常明显：与其反复从头开发，不如尽可能的重用已有代码

### 代码复用具体带来的好处如下：

+ 提高软件质量

  + 通过复用经过测试和验证的代码，可以显著提高软件的整体质量。已有的代码库往往经过了多次使用和迭代，这意味着它们更不可能包含严重的错误或漏洞
  + 此外，当发现问题或需要更新时，只需在一个地方修改代码，就可以在所有使用了该代码的地方反映出这些更改，从而确保了软件产品的一致性和可靠性

+ 加快开发速度

  + 代码复用可以显著加快开发速度。开发人员可以利用现有的功能模块作为构建新应用或功能的基础，避免了重复的工作和资源浪费
  + 这样，他们可以将更多的时间和精力集中在新增功能的创新和实现上，而不是重新发明轮子

+ 促进模块化和解耦

  + 良好的代码复用策略鼓励开发者编写模块化和解耦的代码
  + 通过将代码组织成独立、可重用的模块，开发者可以更容易地理解、测试和维护代码
  + 这种模块化的方法还促进了更清晰的架构设计，使得软件系统更加灵活，适应未来需求的变化

+ 代码复用的示例：

  + 函数
  + 类
  + 模块
  + 组件
  + 库
  + 框架
  + ....


## 特征2 扩展性

+ 变化是程序员生命中唯一不变的事情

  + 你在 Windows 平台上发布了一款游戏， 但现在人们想要 macOS 的版本
  + 你创建了一个使用方形按钮的 GUI 框架，但几个月后圆形按钮开始流行起来
  + 你设计了一款优秀的电子商务网站构架， 但仅仅几个月后，客户就要求新增接受电话订单的功能
  + 当我们开发一个软件的时候，不可能在一开始就想到所有的场景，罗列出完备的需求

+ 因此，这就要求我们的程序是具备可扩展性（Scalability）的

+ 扩展性是衡量软件设计优良与否的重要指标之一，当软件的需求增加或变化时，拥有扩展性意味着能够更加容易地添加新功能或增强现有功能，而不需要对现有代码进行大规模的重构

### 实现扩展性的策略

+ 遵循设计原则：如SOLID原则，特别是开放封闭原则（Open-Closed Principle），它鼓励我们设计模块时应该是对扩展开放的，而对修改封闭的。这意味着在不修改现有代码的情况下，可以通过添加新代码来扩展软件的功能。

+ 预留扩展点：在设计软件时，通过预留扩展点（如插件系统、钩子或回调函数）允许未来的开发者在不直接修改核心代码的情况下，增加新的功能或者修改行为。这里举一个回调函数的例子：

  ```js
  function fetchUserData(url, callback) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);

    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4 && xhr.status === 200) {
        // 当请求成功完成时，解析响应数据
        const responseData = JSON.parse(xhr.responseText);

        // 调用回调函数处理响应数据
        if (typeof callback === "function") {
          callback(responseData);
        }
      }
    };

    xhr.send();
  }

  // 定义一个回调函数来处理获取到的用户数据
  function handleUserData(data) {
    console.log("Received user data:", data);
    // 在这里可以添加更多对数据的处理逻辑
  }

  // 调用 fetchUserData 函数，传入URL和处理响应的回调函数
  const url = "https://example.com/api/user";
  fetchUserData(url, handleUserData);
  ```

+ 很明显，这里在设计 fetchUserData 函数的时候，callback 就是一个扩展点，允许用户传递自己的逻辑，但是整个 fetchUserData 函数内部的逻辑是不变的

+ 采用模块化和微服务架构：将应用分解为一组小的、松散耦合的模块或服务，每个都有明确的责任。这样，当需求变化或需要添加新功能时，只需修改或添加相关的模块或服务，而不会影响到整个系统。
