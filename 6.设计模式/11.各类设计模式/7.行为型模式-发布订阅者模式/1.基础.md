# 发布订阅者模式

## 概述

+ 发布订阅模式可以看作是观察者模式的一种升级版本，和观察者模式在结构上比较相似，但是它们在进行消息传递的时候，传递方式会有所不同

## 发布订阅模式 与 观察者模式 的区别

+ 观察者模式

  + 直接通信：在观察者模式中，观察者（Observer）直接订阅主体（Subject）。当主体发生改变时，它直接通知这些观察者
  + 双向依赖：观察者需要知道主体，主体需要维护一个观察者列表
  + 主体状态：观察者通常对主体的状态变化感兴趣，它们可能会从主体中检索状态
  + 实例：很多GUI工具使用观察者模式，例如，一个按钮（主体）可以有多个事件监听器（观察者）

  + 观察者模式更多用于单一应用程序中对象间的通信，其中观察者通常对主体的状态和状态变化感兴趣

+ 发布订阅模式

  + 间接通信：发布-订阅模式使用一个称作代理（Broker）或消息中介（Message Queue）的第三方组件，发布者（Publisher）不直接发送消息给订阅者（Subscriber），而是通过消息中介
  + 解耦：发布者和订阅者不需要知道对方的存在。它们只需要知道相关的消息或事件类型
  + 异步通信：通常发布-订阅模式支持异步处理，订阅者可以在未来的任何时间点处理收到的消息
  + 动态关系：订阅者可以根据需要随时订阅或取消订阅消息
  + 实例：消息队列（如 RabbitMQ）、流处理（如 Kafka）和许多现代应用框架使用发布-订阅模式
  + 发布-订阅模式通常用于大型、分布式系统中，以消息中介来解耦发布者和订阅者

+ 两者虽然在概念上相似，但在实现细节和使用上有明显区别，选择哪一个取决于你的应用场景和需求

  ![alt text](<发布订阅模式与观察者模式.png>)

## 使用场景

+ 场景1 跨组件通信：尤其适用于没有直接父子关系或层级较深的组件之间传递消息。例如：

  + 用户在应用的某个角落登录成功后，需要通知页面顶部的 Header 组件更新显示用户信息

  + 一个设置面板 (Settings Panel) 的更改需要通知应用中多个不同的展示组件进行相应调整

+ 场景2 全局通知/反馈系统：

  + 当进行异步操作（如 API 请求）成功或失败时，可以发布一个全局事件（如 api:success, api:error），一个专门的通知组件（如 Toast 或 Snackbar）订阅这些事件来向用户显示反馈信息
  + 这样，任何发起 API 请求的模块都不需要直接关心 UI 反馈的具体实现

+ 场景3 解耦应用模块/功能：

  + 在一个大型应用中，不同的功能模块（如用户模块、订单模块、分析模块）可以通过事件总线进行通信，而无需相互直接依赖
  + 例如，订单模块在创建新订单后可以发布 order:created 事件，分析模块可以订阅此事件来记录相关数据

+ 场景4 状态管理辅助：

  + 虽然像 Redux, Vuex, Pinia 这样的状态管理库有自己的机制，但有时在它们之外，或者在不使用这些库的小型项目中，可以使用 Event Bus 来响应某些状态相关的变化，通知相关组件更新
  + 不过要注意，过度依赖 Event Bus 进行状态管理可能会让数据流变得混乱，通常推荐使用专门的状态管理方案

+ 场景5 封装和广播浏览器原生事件：

  + 有时多个组件都需要响应同一个浏览器事件（如 window.resize, online/offline 状态变化）
  + 可以创建一个服务来监听这些原生事件，然后通过 Event Bus 发布自定义事件（如 system:resized, network:statusChanged），让需要的组件订阅这些自定义事件，避免了多处重复添加原生事件监听器以及方便管理

+ 场景6 微前端通信」：

  + 在微前端架构中，不同的子应用（微应用）通常运行在隔离的环境中，发布订阅模式是实现它们之间通信的常用且有效的方案之一
  + 主应用可以提供一个全局的 Event Bus 实例，供各个微应用注册、发布和订阅事件

## 注意事项和最佳实践

+ 「及时取消订阅 (Unsubscribe)」 ：这是 「最重要」 的一点

  + 在组件销毁或不再需要监听时，「必须」 调用 unsubscribe 或 off 方法移除监听器，否则会导致 「内存泄漏」
  + 在 Vue 中通常在 unmounted 或 beforeUnmount 钩子中执行，在 React 中则在 useEffect 的清理函数中执行

+ 「清晰的事件命名」：制定一套统一、清晰的事件命名规范（例如使用 模块名:事件名 或 行为:状态 的格式），避免命名冲突和歧义

  + 最好有文档记录所有全局事件及其用途和载荷 (payload) 结构

+ 「避免滥用」：不要把所有的组件通信都用发布订阅模式来解决

  + 对于简单的父子组件通信，使用 Props 和 Emit (Vue) 或 Props 和回调 (React) 通常更直接、更清晰。对于跨层级的状态共享，优先考虑 Context API (React) 或 Provide/Inject (Vue) 或专门的状态管理库

  + 只有当组件关系复杂、确实需要解耦时，Pub/Sub 才是好的选择

+ 「Payload 结构约定」：发布事件时携带的数据（Payload）应该有明确的结构约定，方便订阅者正确解析和使用

  + 使用 TypeScript 可以提供类型安全

+ 「考虑调试」：意识到 Pub/Sub 会让数据流变得不那么直观，调试时可能需要借助浏览器的开发者工具、日志或者库提供的调试工具来追踪事件的发布和订阅链条

## 第三方库

+ mitt: 一个非常小巧（约 200 字节）且流行的库，API 简洁

+ pubsub-js: 一个功能更全面的老牌库，支持层级主题等

+ 「框架内置或生态系统中的工具」:

  + Vue 2 有 $on, $off, $emit (主要用于父子通信，但也可用于 Event Bus，Vue 3 中已不推荐此方式用于跨组件通信，建议使用 mitt 或状态管理库)

  + Node.js 的 EventEmitter 类

  + 一些状态管理库（如 Redux, Vuex, Pinia）的 action/mutation 机制在某种程度上也体现了类似的思想（集中处理状态变更请求）
