# 简单工厂模式

## 概述

+ 工厂模式同样是属于创建型模式的一种

+ 定义：

  + 在创建对象的时候，不会对客户端暴露具体的创建逻辑，通过工厂所提供的一个统一的接口来得到对象

+ 在工厂模式里面，主要涉及到两个概念（角色）：

  + 工厂：该角色负责创建具体的对象，对外部隐藏了具体的创建逻辑
  + 产品：通过调用工厂给客户端提供的接口，所得到的对象

## 变体

+ 整个工厂模式有三种变体：

  + 简单工厂模式
  + 工厂方法模式
  + 抽象工厂模式


## 简单工厂模式

+ 简单工厂模式实际上并不是 GoF 所提出的 23 种设计模式里面的一种，更像是一种编程习惯

+ 但是这种简单工厂模式的编写习惯存在一定的问题

## 简单工厂存在的问题

+ 假设现在我们有这样的一个需求：

  + 假设我们有一个日志记录系统，需要根据不同的环境（如文件日志、数据库日志）来记录日志

+ 那么根据我们上节课所介绍的简单工厂模式，写出来的代码如下：

  ```js
  // 产品对应的统一接口
  interface Logger {
    log(message: string): void;
  }

  // 文件的形式记录日志
  // 实现了 Logger 接口
  class FileLogger implements Logger {
    log(message: string) {
      console.log(`File log: ${message}`);
    }
  }

  // 数据库的形式记录日志
  // 实现了 Logger 接口
  class DatabaseLogger implements Logger {
    log(message: string) {
      console.log(`Database log: ${message}`);
    }
  }

  // 一个工厂类
  // 提供了 createLogger 方法，根据不同参数来创建不同的产品
  class LoggerFactory {
    static createLogger(type: string): Logger {
      switch (type) {
        case "file":
          return new FileLogger();
        case "database":
          return new DatabaseLogger();
        default:
          throw new Error("Unknown logger type");
      }
    }
  }

  const logger = LoggerFactory.createLogger("file");
  logger.log("This is a message.");
  ```

+ 简单工厂模式所存在的问题：

  + 工厂类的职责过重，每一次需要新增一个类型的产品的时候，都需要修改工厂类内部的逻辑，不符合设计原则里面的开放-封闭原则
