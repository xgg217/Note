# scale核心原理

## 概述

+ 其实就是使用 transform: scale()通过数学计算保持内容宽高比例不变，同时通过缩放使内容始终充满目标容器



## 缩放过程

+ 假设设计稿尺寸为 1920x1080，目标屏幕尺寸为 1440x900，缩放过程如下：

1. 计算宽高比例

  + 宽度比例：1440/1920 = 0.75
  + 高度比例：900/1080 ≈ 0.833

2. 取最小比例 为了保证内容完整显示且不溢出，取 0.75 作为缩放比例（以宽度为基准）

3. 应用缩放 将内容缩小到 75%，此时实际渲染尺寸为：

  + 宽度：1920 * 0.75 = 1440（完美匹配目标宽度）
  + 高度：1080 * 0.75 = 810（小于目标高度 900，上下留黑边）

4. 居中定位 通过 transform 或者其他属性进行调整位置，使内容垂直/水平居中

## 关键点解析
1. transform-origin: 0 0 确保缩放以左上角为基准点，便于后续定位计算

2. 比例计算逻辑

  ```js
  scale = Math.min(当前宽度/设计宽度, 当前高度/设计高度)
  ```

  + 这种算法保证内容始终完整显示，可能出现黑边但不会溢出

3. 垂直/水平补偿量公式

  ```js
  offsetY = (当前视口高度 - 设计高度×缩放比例) / (2 × 缩放比例)
  offsetX = (当前视口宽度 - 设计宽度×缩放比例) / (2 × 缩放比例)
  ```

  + 为什么除以缩放比例？ 因为 translate 的移动距离是基于缩放后的坐标系。例如：

    + 如果缩放比例为 0.5，translateY(100px) 实际上会移动 50px 的物理像素
    + 需要反向补偿：目标物理像素移动量 / scale
  + 当然，简单点，其实也可以直接使用margin或者left、top等属性

## 缺点

+ 使用scale方案是现在一些中小项目比较常用的方案，主要是代码简单方便，封装之后，基本不会涉及到后续一些处理，但是也有非常突出的一些问题：

+ 当大屏跟 ui 稿的比例不一样时，会出现周边留白情况
+ 缩放后可能文本模糊
+ 地图上的点位会出现偏移/点击位置不准
+ 在使用第三方组件时，比如下拉框等不会缩放

## 示例

+ 示例

  ```html
  <!DOCTYPE html>
  <html>
    <head>
      <style>
        #design-container {
          width: 1920px;
          height: 1080px;
          position: fixed;
          transform-origin: 0 0; /* 依然保持左上角基准点 */
          background: #f0f0f0;
        }
        .dashboard-item {
          width: 500px;
          height: 300px;
          background: #3498db;
          position: absolute;
          left: 200px;
          top: 150px;
        }
      </style>
    </head>
    <body>
      <div id="design-container">
        <div class="dashboard-item"></div>
      </div>

      <script>
        function adjustScale() {
          const designWidth = 1920;
          const designHeight = 1080;
          const container = document.getElementById("design-container");

          // 获取当前视口尺寸
          const currentWidth = window.innerWidth;
          const currentHeight = window.innerHeight;

          // 计算缩放比例（取最小值保证内容完整）
          const scale = Math.min(
            currentWidth / designWidth,
            currentHeight / designHeight
          );

          // 计算垂直居中补偿量
          const offsetY = (currentHeight - designHeight * scale) / (2 * scale);
          // 计算水平居中补偿量
          const offsetX = (currentWidth - designWidth * scale) / (2 * scale);

          // 计算居中
          // container.style.left = (currentWidth - designWidth * scale) / 2 + "px";
          // container.style.top = (currentHeight - designHeight * scale) / 2 + "px";

          // 应用变换：先缩放 -> 后平移
          container.style.transform = `
          scale(${scale})
          translate(${offsetX}px, ${offsetY}px)
        `;
        }

        // 初始化与响应式
        adjustScale();
        window.addEventListener("resize", adjustScale);
      </script>
    </body>
  </html>
  ```
