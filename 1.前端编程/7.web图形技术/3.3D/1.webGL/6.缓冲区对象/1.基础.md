# 缓冲区

## 缓冲区的作用

+ 对于图形，可能需要多个点组成，这样就需要将一个图形中所有的顶点全部传入到顶点着色器，然后才能把图形化出来，webgl就提供了一种比较方便的机制——缓冲区对象，它可以一次性的向着色器传入多个顶点的数据

  ```js
  // 顶点数据
  const vertices=new Float32Array([
    //x    y
    0.0,  0.1, //顶点
    -0.1,-0.1, //顶点
    0.1, -0.1  //顶点
  ])
  ```

+ 缓冲区对象是webgl系统中的一块区域，可以一次性的向缓冲区对象中填入大量顶点数据，然后将这些数据保存在其中，供顶点着色器使用

## 步骤

+ 我们在用js定点位的时候，肯定是要建立一份顶点数据的，这份顶点数据是给谁的呢？肯定是给着色器的，因为着色器需要这份顶点数据绘图

+ 然而，我们在js中建立顶点数据，着色器肯定是拿不到的，这是语言不通导致的

+ 为了解决这个问题，webgl 系统就建立了一个能翻译双方语言的缓冲区。js 可以用特定的方法把数据存在这个缓冲区中，着色器可以从缓冲区中拿到相应的数据

+ 接下来咱们就看一下这个缓冲区是如何建的，着色器又是如何从其中拿数据的

+ 步骤1 建立顶点数据，两个浮点数构成一个顶点，分别代表x、y 值

  ```js
  // 顶点数据
  // 这些顶点数据是存储在js 缓存里的，着色器拿不到，所以咱们需要建立一个着色器和js 都能进入的公共区
  const vertices=new Float32Array([
    //x    y
    0.0,  0.1, //顶点
    -0.1,-0.1, //顶点
    0.1, -0.1  //顶点
  ])
  ```

+ 步骤2 建立缓冲对象

  ```js
  // 这个缓冲区是独立存在的，它只是一个空着的仓库，和谁都没有关系
  // 接下来咱们就让其和着色器建立连接
  const vertexBuffer=gl.createBuffer();
  ```

+ 步骤3 绑定缓冲对象

  ```js
  // 当缓冲区和着色器建立了绑定关系，我们就可以往这块空间写入数据了
  gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);
  ```

+ 步骤4 往缓冲区对象中写入数据

  ```js
  // 现在着色器虽然绑定了缓冲区，可以访问里面的数据了，但是我们还得让着色器知道这个仓库是给哪个变量的，比如咱们这里用于控制点位的attribute 变量。这样做是为了提高绘图效率
  gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);
  ```

+ 步骤5 将缓冲区对象分配给attribute 变量

  ```js
  // 到了这里，着色就知道缓冲区的数据是给谁的了。因为咱们缓冲区里的顶点数据是数组，里面有多个顶点。所以我们得开启一个让着色器批量处理顶点数据的属性
  // 默认着色器只会一个一个的接收顶点数据，然后一个一个的绘制顶点
  const a_Position=gl.getAttribLocation(gl.program,'a_Position');
  gl.vertexAttribPointer(a_Position,2,gl.FLOAT,false,0,0);
  ```

+ 步骤6 开启顶点数据的批处理功能

  ```js
  gl.enableVertexAttribArray(a_Position);
  ```

+ 步骤7 绘图

  ```js
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawArrays(gl.POINTS, 0, 3);
  ```
