# 基本对象工具

## `Partial<T>` 全部可选

+ 将一个类型的所有属性设置为 **可选**

  ```js
  interface User {
    age: number
    name: string
  }

  const u:Partial<User> = {
    age: 12
  }
  ```

+ 源码

  ```js
  type Partial<T> = {
    [P in keyof T]?: T[P];
  };
  ```

## Required<T> 全部必填

+ 将一个类型的所有属性设置为 **必填**

  ```js
  interface User {
    age: number
    name: string
  }

  const u:Partial<User> = {
    age: 12
  }
  ```

+ 源码

  ```js
  type Required<T> = {
    [P in keyof T]-?: T[P];
  };
  ```

## `Readonly<T>` 全部只读

+ 将类型 T 中的成员变成 **只读**

  ```js
  type Readonly<T> = {
    readonly [P in keyof T]: T[P]
  }
  ```

+ `Readonly` 中也可以使用 `+readonly` `-readonly`

  ```js
  type Readonly<T> = {
    +readonly [P in keyof T]: T[P];
  };
  ```

  ```js
  type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
  };
  ```

+ 使用示例

  ```js
  // 使用
  interface Todo {
    title: string
    description: string
  }

  const todo: Readonly<Todo> = {
    title: "Hey",
    description: "foobar"
  }

  todo.title = "Hello" // Error: 无法分配到 "title" ，因为它是只读属性
  todo.description = "barFoo" // Error: 无法分配到 "title" ，因为它是只读属性
  ```

## Record<K, T>

+ `Record<K, T>` 创建一个具有特定键类型和值类型的对象类型

  ```js
  type PagePaths = Record<'home' | 'about' | 'contact', string>;
  /* 等价于：
  {
    home: string;
    about: string;
    contact: string;
  }
  */

  type UserMap = Record<number, User>;
  /* 等价于：
  {
    [key: number]: User;
  }
  */
  ```

## KeyOf<T> 获取所有键 -- 自定义

+ `KeyOf<T>` - 获取类型 T 的所有键名的联合类型

  ```js
  declare type KeyOf<T> = keyof T;

  // 示例
  type Obj = { a: number; b: string };
  type Keys = KeyOf<Obj>; // "a" | "b"
  ```

