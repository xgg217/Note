# 类的泛型支持

## 基本使用

+ 基本使用

  ```js
  class SimpleSet<T> {
    private elements: Map<T, boolean>;

    constructor() {
      this.elements = new Map();
    }

    add(element: T): this {
      this.elements.set(element, true);
      return this; // 链式调用
    }

    has(element: T): boolean {
      return this.elements.has(element);
    }

    values(): T[] {
      return [...this.elements.keys()];
    }
  }

  class MutableSet<T> extends SimpleSet<T> {
    constructor() {
      super();
    }

    show() {
      console.log("MutableSet show");
    }
  }

  // 父类
  const s = new SimpleSet<number>();

  console.log(s.add(1).add(2).add(3).values());

  // 子类
  const m = new MutableSet<number>();
  console.log(m.add(1).add(2).add(3).show());
  ```

## 静态成员的泛型

+ 静态成员的泛型需要手动指定

  ```js
  class SimpleSet<T> {
    constructor() {
      this.elements = new Map();
    }

    add(element: T): this {
      this.elements.set(element, true);
      return this; // 链式调用
    }

    static of<E>(...ele:E[]):SimpleSet<E> {
      const set = new SimpleSet<E>();
      ele.forEach(e => {
        set.add(e);
      });
      return set;
    }
  }

  const m1 = MutableSet.of("1", "2", "3");
  console.log(m1.values()); // ['1', '2', '3']
  ```

