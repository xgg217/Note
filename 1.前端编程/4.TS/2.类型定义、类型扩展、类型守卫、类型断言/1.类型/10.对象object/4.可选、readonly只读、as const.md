# 4.可选、readonly只读、as const

## 可选属性

+ 如果某个属性是可选的（即可以忽略），需要在属性名后面加一个问号

  ```js
  const obj: {
    x: number;
    y?: number;
  } = { x: 1 };
  ```

+ 可选属性等同于允许赋值为 `undefined` ，下面两种写法是等效的

  ```js
  type User = {
    firstName: string;
    lastName?: string;
  };

  // 等同于
  type User = {
    firstName: string;
    lastName: string|undefined;
  };
  ```

+ 同理，读取一个可选属性时，有可能返回 `undefined`

  ```js
  type MyObj = {
    x: string,
    y?: string
  };

  const obj:MyObj = { x: 'hello' };
  obj.y.toLowerCase() // 报错
  ```

  ```js
  // 解决办法：检查一下是否为undefined
  const user:{
    firstName: string;
    lastName?: string;
  } = { firstName: 'Foo'};

  // 写法一
  let firstName = (user.firstName === undefined)
    ? 'Foo' : user.firstName;
  let lastName = (user.lastName === undefined)
    ? 'Bar' : user.lastName;

  // 写法二
  let firstName = user.firstName ?? 'Foo';
  let lastName = user.lastName ?? 'Bar';
  ```


## readonly

+ 属性名前面加上 `readonly` 关键字，表示这个属性是只读属性，不能修改

  ```js
  interface MyInterface {
    readonly prop: number;
  }
  ```

  ```js
  const person:{
    readonly age: number
  } = { age: 20 };

  person.age = 21; // 报错
  ```

+ 使用场景: 只读属性只能在对象初始化期间赋值，此后就不能修改该属性

  ```js
  type Point = {
    readonly x: number;
    readonly y: number;
  };

  const p:Point = { x: 0, y: 0 };

  p.x = 100; // 报错
  ```

## as const

+ 当你初始化变量为一个对象的时候，TypeScript 会假设这个对象的属性的值未来会被修改

  ```js
  // TypeScript 并不会认为 obj.counter 之前是 0， 现在被赋值为 1 是一个错误
  // 换句话说，obj.counter 必须是 number 类型，但不要求一定是 0，因为类型可以决定读写行为
  const obj = { counter: 0 };
  if (someCondition) {
    obj.counter = 1; // 允许重新赋值
  }
  ```

+ 使用场景

  ```js
  // 下面代码会报错
  // 原因：req.method 被推断为 string ，而不是 "GET"，因为在创建 req 和 调用 handleRequest 函数之间，可能还有其他的代码，或许会将 req.method 赋值一个新字符串比如 "Guess" 。所以 TypeScript 就报错了
  declare function handleRequest(url: string, method: "GET" | "POST"): void;

  const req = { url: "https://example.com", method: "GET" };
  handleRequest(req.url, req.method); // 报错：类型“string”的参数不能赋给类型“"GET" | "POST"”的参数
  ```

  ```js
  // 解决方案1：添加一个类型断言改变推断结果：
  const req = { url: "https://example.com", method: "GET" as "GET" };

  handleRequest(req.url, req.method as "GET");
  ```

  ```js
  // 解决方案2：使用 as const 把整个对象转为一个类型字面量
  const req = { url: "https://example.com", method: "GET" } as const;
  handleRequest(req.url, req.method);
  ```
