# 可选元组 、 只读元组 、 具名元组

## 可选元组

+ 元组也支持了在某一个位置上的可选成员
+ *注意*，问号只能用于元组的尾部成员，也就是说，所有可选成员必须在必选成员之后

  ```js
  const arr6: [string, number?, boolean?] = ['linbudu'];

  // 下面这么写也可以
  // const arr6: [string, number?, boolean?] = ['linbudu', , ,];
  ```

+ 长度属性也会发生变化

  ```js
  const arr6: [string, number?, boolean?] = ['linbudu'];

  // 元组的长度可能为 1、2、3
  type TupleLength = typeof arr6.length; // 1 | 2 | 3
  ```

## 只读元组

+ 元组也可以是只读的，不允许修改，有两种写法

  ```js
  // 写法一
  type t = readonly [number, string]

  // 写法二
  type t = Readonly<[number, string]>
  ```

+ 跟数组一样，只读元组是元组的父类型。所以，元组可以替代只读元组，而*只读元组不能替代元组*

  ```js
  type t1 = readonly [number, number];

  type t2 = [number, number];

  let x:t2 = [1, 2];
  let y:t1 = x; // 正确

  x = y; // 报错
  ```

## 具名元组

+ 可能会觉得，元组的可读性实际上并不好
+ 比如对于 `[string, number, boolean]` 来说，你并不能直接知道这三个元素都代表什么，还不如使用对象的形式

+ 定义：在 TypeScript 4.0 中，有了具名元组（Labeled Tuple Elements）的支持，使得我们可以为元组中的元素打上类似属性的标记

  ```js
  const arr7: [name: string, age: number, male: boolean] = ['linbudu', 599, true];
  ```

+ 具名元组 + 可选元素

+ 具名元组 + 可选元素

  ```js
  const arr7: [name: string, age: number, male?: boolean] = ['linbudu', 599, true];
  ```
