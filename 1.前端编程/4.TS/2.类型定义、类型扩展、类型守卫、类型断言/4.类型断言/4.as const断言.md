# as const 断言

## 概述

+ `as const` 断言，可以将代码中宽泛的数据类型定义具体话，从而避免我们在开发过程中，因为定义过于宽泛，造成的各种数据处理的错误，通过精准的数据类型定义，更好的管理我们前端代码

+ 注意：不是“强制转换”

## 语法

+ 语法1 `as const`

  ```js
  let y = [10, 'xgg'] as const;
  ```

+ 语法2 `<const>`

  ```js
  let y = <const>[10, 20];
  ```

## 字面量类型

+ 当我们使用关键字 `const` 声明一个字面量时，类型是等号右边的文字（将宽泛的类型，例如：字符串、数字转化成具体值类型）

  ```js
  const x = 'a'; // x 的 类型为 'a'，不可被修改
  ```

+ 用 `let` 而不是 `const`， 那么该变量会被重新分配，并且类型会被扩展为字符串类型

  ```js
  // x是宽泛的字符串类型，只要是字符串，即可赋值给变量x
  let x = 'a'; // string 类型
  ```

+ 使用 `as const`

  ```js
  let y = 'a' as const; // x 的 类型为 'a'，不可被修改
  ```

 ```js
  let x = "hello" as const;
  x = 'hello';  // ✅
  x = 'xx'; // ❌ 不能将类型“"xx"”分配给类型“"hello"”
  ```

## 数组

+ 未使用 `as const`

  ```js
  const colors = ["red", "green", "blue"]
  typeof colors //  string[]
  ```

+ 使用 `as const` 就是告诉 TypeScript，推断类型时要把变量arr推断为只读数组，从而使得数组成员无法改变

  ```js
  const colors = ["red", "green", "blue"] as const;
  typeof colors //  readonly [1, "green", "blue"]
  ```

+ 很适合用于函数的 rest 参数

  ```js
  function add(x:number, y:number) {
    return x + y;
  }

  // 报错写法
  const nums = [1, 2];
  const total = add(...nums);

  // 正确写法
  const nums = [1, 2] as const;
  const total = add(...nums);
  ```

## 对象属性

+ `as const` 断言对象的单个属性

  ```js
  const v1 = {
    x: 1,
    y: 2,
  }; // 类型是 { x: number; y: number; }

  const v2 = {
    x: 1 as const,
    y: 2,
  }; // 类型是 { x: 1; y: number; }
  ```

## 对象

+ 当你初始化变量为一个对象的时候，TypeScript 会假设这个对象的属性的值未来会被修改

  ```js
  const config = { host: "localhost", port: 8080 }
  // 类型
  typeof config // { host: string, port: number }
  ```

+ 使用 `as const` 相当于在每个属性中附加了 `readonly` 修饰符

  ```js
  const config = { host: "localhost", port: 8080 } as const
  // 相当于
  const config: {
    readonly host: "localhost";
    readonly port: 8080;
  }
  ```

+ 示例 1

  ```js
  let obj = {
    x: 10,
    y: [20, 30],
    z: {
      a: {  b: 42 }
    }
  } as const;

  // 对应于：
  let obj: {
    readonly x: 10;
    readonly y: readonly [20, 30];
    readonly z: {
      readonly a: {
        readonly b: 42;
      };
    };
  };
  ```

+ 示例2

  ```js
  // 下面代码会报错
  // 原因：req.method 被推断为 string ，而不是 "GET"，因为在创建 req 和 调用 handleRequest 函数之间，可能还有其他的代码，或许会将 req.method 赋值一个新字符串比如 "Guess" 。所以 TypeScript 就报错了
  declare function handleRequest(url: string, method: "GET" | "POST"): void;

  const req = { url: "https://example.com", method: "GET" };
  handleRequest(req.url, req.method); // 报错：类型“string”的参数不能赋给类型“"GET" | "POST"”的参数
  ```

  ```js
  // 解决方案1：添加一个类型断言改变推断结果：
  const req = { url: "https://example.com", method: "GET" as "GET" };

  handleRequest(req.url, req.method as "GET");
  ```

  ```js
  // 解决方案2：使用 as const 把整个对象转为一个类型字面量
  const req = { url: "https://example.com", method: "GET" } as const;
  handleRequest(req.url, req.method);
  ```

## 解构

+ 示例

  ```js
  function asConst(){
    let a:string = "abc";
    let b = (firstname:string,lastname:string):string => firstname + lastname;
    return [a,b];
  }

  let [p,q] = asConst();
  q("Green","Tom"); // 报错 原因是系统认为变量q的类型是string | ((firstname: string, lastname: string) => string)，编译器并不能认定q是一个函数

  // 解决办法
  (function() {
    function asConst(){
      let a:string = "abc";
      let b = (firstname:string,lastname:string):string => firstname + lastname;
      return [a,b] as const; // 返回值由宽泛变成具体的
  }
  ```

## Enum

+ 使用 `as const` 断言

  ```js
  enum Foo {
    X,
    Y,
  }
  // 变量e1的类型被推断为整个 Enum 类型
  let e1 = Foo.X;            // Foo

  // 变量e2的类型被推断为 Enum 的某个成员
  let e2 = Foo.X as const;   // Foo.X
  ```
