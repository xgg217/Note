# renderer

## 默认renderer上修改

+ 在components/custom文件夹下新建一个CustomRenderer.js文件, 用来自定义renderer.

由于是在bpmn.js已有的元素上进行修改, 所以首先我们可以先将BaseRenderer这个类引入进来, 然后让我们的自定义renderer继承它:

  ```js
  import BaseRenderer from "diagram-js/lib/draw/BaseRenderer"; // 引入默认的renderer
  const HIGH_PRIORITY = 1500; // 最高优先级
  export default class CustomRenderer extends BaseRenderer {
    // 继承BaseRenderer
    constructor(eventBus, bpmnRenderer) {
      super(eventBus, HIGH_PRIORITY);
      this.bpmnRenderer = bpmnRenderer;
    }

    canRender(element) {
      // ignore labels
      return !element.labelTarget;
    }

    drawShape(parentNode, element) {
      // 核心函数就是绘制shape
      const shape = this.bpmnRenderer.drawShape(parentNode, element);
      return shape;
    }

    getShapePath(shape) {
      return this.bpmnRenderer.getShapePath(shape);
    }
  }

  CustomRenderer.$inject = ["eventBus", "bpmnRenderer"];

  ```

+ index.js中加入CustomRenderer

  ```js
  import CustomPalette from "./CustomPalette";
  import CustomRenderer from "./CustomRenderer";

  export default {
    __init__: ["customPalette", "customRenderer"],
    customPalette: ["type", CustomPalette],
    customRenderer: ['type', CustomRenderer]
  };
  ```

+ 回到之前的vue页面，同样加入customModule

  ```js
  modeler = new Modeler({
    container: canvasRef.value,
    additionalModules: [
      // 自定义的节点
      customModule,
    ],
  });
  ```

+ 当然，现在的渲染界面没有任何变化，因为我们还需要编写drawShape这个方法。

+ 同时为了方便处理，我们创建一个工具函数，utils/util.js

  ```js
  const customElements = ['bpmn:Task'] // 自定义元素的类型
  const customConfig = { // 自定义元素的配置
      'bpmn:Task': {
          'url': '/src/assets/box.png',
          'attr': { x: 0, y: 0, width: 48, height: 48 }
      }
  }

  export { customElements, customConfig }
  ```

+ 由于画布中的图形为 SVG，所以需要通过SVG进行画图，BPMN 提供了一个 SVG 库 tiny-svg

+ 我们可以先导入这个库

  ```js
  pnpm add tiny-svg
  ```

+ 重新编写drawShape方法.

  ```js
  import BaseRenderer from "diagram-js/lib/draw/BaseRenderer"; // 引入默认的renderer
  import { customElements, customConfig } from "@/components/utils/utils"; // 引入自定义元素和配置
  import {
      append as svgAppend,
      create as svgCreate
  } from 'tiny-svg';

  const HIGH_PRIORITY = 1500; // 最高优先级
  export default class CustomRenderer extends BaseRenderer {
    // 继承BaseRenderer
    constructor(eventBus, bpmnRenderer) {
      super(eventBus, HIGH_PRIORITY);
      this.bpmnRenderer = bpmnRenderer;
    }

    canRender(element) {
      // ignore labels
      return !element.labelTarget;
    }

    drawShape(parentNode, element) {
      const type = element.type; // 获取到类型
      console.log(type)
      if (customElements.includes(type)) {
        const { url, attr } = customConfig[type];
        const customIcon = svgCreate("image", {
          // 在这里创建了一个image
          ...attr,
          href: url,
        });
        element["width"] = attr.width;
        element["height"] = attr.height;
        svgAppend(parentNode, customIcon);
        return customIcon;
      }
      const shape = this.bpmnRenderer.drawShape(parentNode, element);
      return shape;
    }

    getShapePath(shape) {
      return this.bpmnRenderer.getShapePath(shape);
    }
  }

  CustomRenderer.$inject = ["eventBus", "bpmnRenderer"];

  ```

+ 这里返回的 shape，其实就是一个 SVG

+ 当然，上面我们是取巧，直接创建了一个image的图案，自己去画一个svg也行。

  ```js
  import BaseRenderer from "diagram-js/lib/draw/BaseRenderer"; // 引入默认的renderer
  import { customElements, customConfig } from "@/components/utils/utils"; // 引入自定义元素和配置
  import {
    append as svgAppend,
    attr as svgAttr,
    create as svgCreate,
    remove as svgRemove
  } from "tiny-svg";

  import { is } from 'bpmn-js/lib/util/ModelUtil';

  const HIGH_PRIORITY = 1500;// 最高优先级

  export default class CustomRenderer extends BaseRenderer {
    // 继承BaseRenderer
    constructor(eventBus, bpmnRenderer) {
      super(eventBus, HIGH_PRIORITY);
      this.bpmnRenderer = bpmnRenderer;
    }

    canRender(element) {
      // ignore labels
      return !element.labelTarget;
    }

    drawShape(parentNode, element) {
      const shape = this.bpmnRenderer.drawShape(parentNode, element);

      if (is(element, "bpmn:Task")) {
        // 当元素类型是 bpmn:Task 时
        const rect = drawRect(parentNode, 100, 80, 2, "#52B415"); // 创建一个带绿色边框的矩形

        prependTo(rect, parentNode);

        svgRemove(shape);

        return shape;
      }

      // 其他不属于 bpmn:Task 的元素，如开始事件
      // 也创建一个 红色小矩形
      // const rect = drawRect(parentNode, 30, 20, TASK_BORDER_RADIUS, "#cc0000");
      // 放置于左上角
      // svgAttr(rect, {
      //   transform: "translate(-20, -10)",
      // });

      return shape;
    }

    getShapePath(shape) {
      return this.bpmnRenderer.getShapePath(shape);
    }
  }

  CustomRenderer.$inject = ["eventBus", "bpmnRenderer"];

  // copied from bpmn-js/lib/draw/BpmnRenderer.js
  function drawRect(parentNode, width, height, borderRadius, strokeColor) {
    const rect = svgCreate('rect');

    svgAttr(rect, {
      width: width,
      height: height,
      rx: borderRadius,
      ry: borderRadius,
      stroke: strokeColor || '#000',
      strokeWidth: 2,
      fill: '#fff'
    });

    svgAppend(parentNode, rect);

    return rect;
  }

  // copied from /diagram-js/lib/core/GraphicsFactory.js
  function prependTo(newNode, parentNode, siblingNode) {
    parentNode.insertBefore(newNode, siblingNode || parentNode.firstChild);
  }
  ```