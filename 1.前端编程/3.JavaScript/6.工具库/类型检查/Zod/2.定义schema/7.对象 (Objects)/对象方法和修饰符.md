# 对象方法和修饰符

## .shape 访问类型

+ .shape: 获取定义对象形状的对象

  ```js
  Dog.shape.name; // => string schema
  Dog.shape.age; // => number schema
  ```

  ```js
  const UserSchema = z.object({
    name: z.string(),
    xp: z.number(),
  });

  const OrderSchema = z.object({
    user: UserSchema.shape.name,
    age: z.number(),
  });
  ```

## .keyof() 获取 key 的枚举

+ 获取 key

  ```js
  const Dog = z.object({
    name: z.string(),
    age: z.number().optional(),
  });

  const keySchema = Dog.keyof();
  // => ZodEnum<["name", "age"]>
  ```

## .extend() 继承

+ 要向对象架构添加其他字段

  ```js
  const Dog = z.object({
    name: z.string(),
    age: z.number().optional(),
  });

  const DogWithBreed = Dog.extend({
    breed: z.string(),
  });
  ```

+ 此 API 可用于覆盖现有字段！小心使用这种能力！如果两个模式共享密钥，则 B 将覆盖 A

## 扩展语法

+ .extend() 优化版本

+ 建一个全新的对象模式来完全避免使用 .extend()
+ 这使得生成的 schema 的严格级别在视觉上显而易见

  ```js
  const DogWithBreed = z.object({ // or z.strictObject() or z.looseObject()...
    ...Dog.shape,
    breed: z.string(),
  });
  ```

+ 也可以使用此功能一次性合并多个对象

  ```js
  const DogWithBreed = z.object({
    ...Animal.shape,
    ...Pet.shape,
    breed: z.string(),
  });
  ```

## 方法和修饰符

+ .shape: 获取定义对象形状的对象。UserSchema.shape.username 会给你 username 的 schema
+ .keyof(): 创建一个由对象键组成的枚举 schema。UserSchema.keyof() 会是 z.enum(['id', 'username', 'email', 'age', 'isActive', +'address'])
+ .extend({ newKey: newSchema, ... }): 扩展现有对象 schema，添加新的字段
+ .merge(otherObjectSchema): 合并两个对象 schema

+ .deepPartial(): 递归地使对象及其嵌套对象中的所有字段都变为可选

+ .passthrough(): 默认情况下，Zod 会去除对象中未在 schema 中定义的额外字段。使用 .passthrough() 会保留这些额外字段
+ .strict(message?): 如果对象包含未在 schema 中定义的额外字段，则抛出错误

  ```js
  import { z } from 'zod';

  const BaseUserSchema = z.object({
    id: z.string().uuid(),
    name: z.string(),
  });

  // .extend()
  const AdminUserSchema = BaseUserSchema.extend({
    permissions: z.array(z.string()),
  });
  type AdminUser = z.infer<typeof AdminUserSchema>;
  // { id: string; name: string; permissions: string[] }

  // .passthrough() vs .strict()
  const StrictSchema = z.object({ a: z.string() }).strict();
  const PassthroughSchema = z.object({ a: z.string() }).passthrough();

  console.log(StrictSchema.safeParse({ a: "hello", b: "world" })); // success: false (因为有额外的 'b')
  console.log(PassthroughSchema.safeParse({ a: "hello", b: "world" })); // success: true, data: { a: "hello", b: "world" }
  console.log(z.object({ a: z.string() }).parse({ a: "hello", b: "world" })); // 默认 .strip(), 返回 { a: "hello" }

  // .catchall()
  const DynamicObjectSchema = z.object({
      fixedProp: z.string()
  }).catchall(z.number()); // 其他所有属性都必须是数字
  type DynamicObject = z.infer<typeof DynamicObjectSchema>;
  /*
  {
      fixedProp: string;
      [k: string]: unknown; // z.infer 对 catchall 的推断比较保守
                            // 实际验证时，非 fixedProp 的属性会被 catchall(z.number()) 校验
  }
  */
  console.log(DynamicObjectSchema.parse({ fixedProp: "value", dynamicKey1: 123, dynamicKey2: 456 }));
  // console.log(DynamicObjectSchema.safeParse({ fixedProp: "value", dynamicKey1: "not a number" })); // success: false

  ```

