# 数组

## z.array

+ z.array(elementSchema) : 验证数据是否为数组，并且数组中的每个元素都符合 elementSchema

  ```js
  import { z } from 'zod';

  const stringArraySchema = z.array(z.string()); // 字符串数组
  const numberArraySchema = z.array(z.number()); // 数字数组

  const userSchema = z.object({ name: z.string(), age: z.number() });
  const userArraySchema = z.array(userSchema); // User 对象数组

  console.log(stringArraySchema.parse(["a", "b", "c"]));
  console.log(userArraySchema.parse([{ name: "Alice", age: 30 }, { name: "Bob", age: 25 }]));

  ```

## 数组校验方法

+ .min(minLength, message?): 数组最小长度。
+ .max(maxLength, message?): 数组最大长度。
+ .length(fixedLength, message?): 数组固定长度。
+ .nonempty(message?): 确保数组至少有一个元素 (等同于 .min(1))。

  ```js
  import { z } from 'zod';
  const nonEmptyTagListSchema = z.array(z.string()).nonempty({ message: "标签列表不能为空" });
  const fixedSizeTupleLikeSchema = z.array(z.number()).length(3, { message: "需要恰好3个数字" });

  console.log(nonEmptyTagListSchema.safeParse([])); // success: false
  console.log(nonEmptyTagListSchema.safeParse(["tag1"])); // success: true

  ```

## z.tuple

+ z.tuple([schemaA, schemaB, ...]) : 验证数据是否为元组 (具有固定长度和特定顺序元素类型的数组)

  ```js
  import { z } from 'zod';

  const stringNumberBooleanTuple = z.tuple([
    z.string(),
    z.number(),
    z.boolean(),
  ]);
  type MyTuple = z.infer<typeof stringNumberBooleanTuple>; // [string, number, boolean]

  console.log(stringNumberBooleanTuple.parse(["hello", 123, true]));
  // stringNumberBooleanTuple.parse(["hello", 123]); // 抛出 ZodError (长度不足)
  // stringNumberBooleanTuple.parse(["hello", "world", true]); // 抛出 ZodError (第二个元素类型错误)

  // .rest() 用于元组的剩余元素
  const nameAndScoresSchema = z.tuple([z.string()]).rest(z.number());
  type NameAndScores = z.infer<typeof nameAndScoresSchema>; // [string, ...number[]]
  console.log(nameAndScoresSchema.parse(["Alice", 100, 90, 80]));
  console.log(nameAndScoresSchema.parse(["Bob"])); // 也有效，rest 部分可以为空

  ```
