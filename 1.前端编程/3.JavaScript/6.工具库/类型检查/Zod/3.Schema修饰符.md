# Schema 修饰符

## 概述

+ 可以链式调用到大多数 Zod schema 上，以添加额外的行为或约束

## .optional()

+ `.optional()` : 使 schema 接受 `undefined` 作为有效值
+ 字段可以不存在

  ```js
  import { z } from 'zod';
  const optionalStringSchema = z.string().optional();
  type OptionalString = z.infer<typeof optionalStringSchema>; // string | undefined

  console.log(optionalStringSchema.parse("hello"));
  console.log(optionalStringSchema.parse(undefined));
  // optionalStringSchema.parse(null); // 抛出 ZodError
  ```

## .nullable()

+ `.nullable()` : 使 schema 接受 `null` 作为有效值

  ```js
  import { z } from 'zod';
  const nullableStringSchema = z.string().nullable();
  type NullableString = z.infer<typeof nullableStringSchema>; // string | null

  console.log(nullableStringSchema.parse("hello"));
  console.log(nullableStringSchema.parse(null));
  // nullableStringSchema.parse(undefined); // 抛出 ZodError
  ```

## .nullish()

+ 你可以组合使用 `.optional().nullable()` (或 `.nullable().optional()`) 来表示一个值可以是` T | null | undefined`

+ 更简洁的方式是使用 `.nullish()` ，它等同于 `.optional().nullable()`

  ```js
  const nullishStringSchema = z.string().nullish(); // string | null | undefined
  type NullishString = z.infer<typeof nullishStringSchema>;
  ```

## default

+ `.default(value)` : 如果输入数据为 `undefined` ，则提供一个默认值
+ 注意：它只对 `undefined` 生效，对 `null` 或其他 `falsy` 值无效

  ```js
  import { z } from 'zod';
  const nameSchema = z.string().default("Anonymous");
  type Name = z.infer<typeof nameSchema>; // string

  console.log(nameSchema.parse("Alice"));   // "Alice"
  console.log(nameSchema.parse(undefined)); // "Anonymous" (默认值生效)
  // console.log(nameSchema.parse(null)); // 抛出 ZodError，因为 null 不是 string 也不是 undefined
  ```

+ 如果希望 `null` 也触发默认值，可以使用 `.preprocess()`

  ```js
  const nameOrDefaultSchema = z.preprocess(
    (val) => (val === null ? undefined : val),
    z.string().default("Anonymous")
  );
  console.log(nameOrDefaultSchema.parse(null)); // "Anonymous"
  ```

## 只读 readonly

+ 要将模式标记为只读

  ```js
  const ReadonlyUser = z.object({ name: z.string() }).readonly();
  type ReadonlyUser = z.infer<typeof ReadonlyUser>;
  // Readonly<{ name: string }>
  ```

## describe

+ `.describe(description)` : 为 schema 添加一个描述性字符串
+ 这本身不影响验证，但可以用于文档生成或自定义错误信息

  ```js
  import { z } from 'zod';
  const userIdSchema = z.string().uuid().describe("用户的唯一标识符 (UUID v4)");
  console.log(userIdSchema.description); // "用户的唯一标识符 (UUID v4)"
  ```

## transform

+ `.transform(transformFn)` : 在数据成功通过验证后，对其进行转换
+ transformFn 接收验证后的数据作为参数，并返回转换后的数据

  ```js
  import { z } from 'zod';

  const stringToNumberSchema = z.string()
    .regex(/^\d+$/, "必须是数字字符串")
    .transform(Number); // 将验证后的字符串转换为数字
  type StringToNumber = z.infer<typeof stringToNumberSchema>; // number

  console.log(stringToNumberSchema.parse("123")); // 123 (数字类型)
  // stringToNumberSchema.parse("abc"); // 验证失败 (regex)

  const userFullNameSchema = z.object({
      firstName: z.string(),
      lastName: z.string(),
  }).transform(user => `${user.firstName} ${user.lastName}`);
  type UserFullName = z.infer<typeof userFullNameSchema>; // string

  console.log(userFullNameSchema.parse({ firstName: "Jane", lastName: "Doe" })); // "Jane Doe"
  ```

+ 重要:` z.infer` 推断的是 `transform` 之后的类型

## refine

+ `.refine(validatorFn, messageOrParams)` : 添加自定义验证逻辑
+ validatorFn 接收要验证的数据，如果数据有效则返回 true (或一个 truthy 值)，无效则返回 false (或一个 falsy 值)

  ```js
  import { z } from 'zod';

  const passwordSchema = z.string()
    .min(8, "密码至少需要8个字符")
    .refine(s => /[A-Z]/.test(s), { message: "密码必须包含至少一个大写字母" })
    .refine(s => /[a-z]/.test(s), { message: "密码必须包含至少一个小写字母" })
    .refine(s => /\d/.test(s), { message: "密码必须包含至少一个数字" });

  console.log(passwordSchema.safeParse("Password123")); // success: true
  console.log(passwordSchema.safeParse("password"));    // success: false, 错误信息指向大写字母和数字的 refine

  // refine 可以用于对象级别，例如比较两个字段
  const registrationSchema = z.object({
    password: z.string().min(8),
    confirmPassword: z.string(),
  }).refine(data => data.password === data.confirmPassword, {
    message: "两次输入的密码不匹配",
    path: ["confirmPassword"], // 指定错误关联到 confirmPassword 字段
  });

  console.log(registrationSchema.safeParse({ password: "test1234", confirmPassword: "test1234" })); // success: true
  const result = registrationSchema.safeParse({ password: "test1234", confirmPassword: "test4321" });
  if (!result.success) {
    console.log(result.error.flatten().fieldErrors); // { confirmPassword: [ '两次输入的密码不匹配' ] }
  }
  ```

+ 异步:需要使用 schema.parseAsync()

  ```js
  import { z } from 'zod';

  // 模拟一个异步的用户名唯一性检查
  async function isUsernameUnique(username: string): Promise<boolean> {
    return new Promise(resolve => {
      setTimeout(() => {
        resolve(username !== "existingUser");
      }, 500);
    });
  }

  const asyncUsernameSchema = z.string()
    .min(3, "用户名至少3字符")
    .refine(async (username) => {
      return await isUsernameUnique(username);
    }, "该用户名已被占用");

  async function testAsyncValidation() {
    console.log("开始异步验证 (unique):", await asyncUsernameSchema.safeParseAsync("newUser"));
    // { success: true, data: 'newUser' } (大约500ms后)

    console.log("开始异步验证 (exists):", await asyncUsernameSchema.safeParseAsync("existingUser"));
    // { success: false, error: ... } (大约500ms后，错误信息为 "该用户名已被占用")
  }

  testAsyncValidation();
  ```

## superRefine

+ `.superRefine(superValidatorFn)` : 一个更强大的 refine 版本，它接收一个额外的 ctx (ZodRefinementCtx) 参数
+ ctx 允许你添加多个错误，并且可以指定错误的路径和消息

  ```js
  import { z } from 'zod';

  const complexObjectSchema = z.object({
    startDate: z.date(),
    endDate: z.date(),
    value: z.number(),
  }).superRefine((data, ctx) => {
    if (data.endDate < data.startDate) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom, // 自定义错误码
        message: "结束日期不能早于开始日期",
        path: ["endDate"], // 错误关联到 endDate 字段
      });
    }
    if (data.startDate > new Date() && data.value < 0) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "对于未来的日期，值不能为负",
        path: ["value"],
      });
    }
    // 如果有需要，可以添加更多 issue
  });

  const testData1 = { startDate: new Date("2024-01-15"), endDate: new Date("2024-01-10"), value: 100 };
  const result1 = complexObjectSchema.safeParse(testData1);
  if (!result1.success) {
    console.log("Validation 1 errors:", result1.error.flatten());
    /*
    Validation 1 errors: {
      fieldErrors: { endDate: [ '结束日期不能早于开始日期' ] },
      formErrors: []
    }
    */
  }

  const futureDate = new Date();
  futureDate.setDate(futureDate.getDate() + 5); // 5天后的日期
  const testData2 = { startDate: futureDate, endDate: new Date(futureDate.getTime() + 86400000), value: -10 };
  const result2 = complexObjectSchema.safeParse(testData2);
  if (!result2.success) {
    console.log("Validation 2 errors:", result2.error.flatten());
    /*
    Validation 2 errors: {
      fieldErrors: { value: [ '对于未来的日期，值不能为负' ] },
      formErrors: []
    }
    */
  }
  ```

+ 异步：需要使用schema.safeParseAsync()

  ```js
  import { z } from 'zod';

  // 模拟一个异步的用户名唯一性检查
  async function isUsernameUnique(username: string): Promise<boolean> {
    return new Promise(resolve => {
      setTimeout(() => {
        resolve(username !== "existingUser");
      }, 500);
    });
  }

  const asyncUsernameSchema = z.string()
    .min(3, "用户名至少3字符")
    .refine(async (username) => {
      return await isUsernameUnique(username);
    }, "该用户名已被占用");

  async function testAsyncValidation() {
    console.log("开始异步验证 (unique):", await asyncUsernameSchema.safeParseAsync("newUser"));
    // { success: true, data: 'newUser' } (大约500ms后)

    console.log("开始异步验证 (exists):", await asyncUsernameSchema.safeParseAsync("existingUser"));
    // { success: false, error: ... } (大约500ms后，错误信息为 "该用户名已被占用")
  }

  testAsyncValidation();

  ```

## preprocess

+ `.preprocess(preprocessFn, schema)` : 在数据传递给内部 schema 进行验证之前，对其进行预处理

  + 也可以使用 `z.coerce.number()` 等

+ preprocessFn 接收原始输入，其返回值将被传递给 schema 进行验证
+ 这对于在验证前转换数据类型或格式非常有用

  ```js
  import { z } from 'zod';

  // 示例：将输入的字符串（如果是数字字符串）或数字统一转换为数字
  const flexibleNumberSchema = z.preprocess(arg => {
    if (typeof arg === "string") {
      const num = parseFloat(arg);
      return isNaN(num) ? arg : num; // 如果不能转为数字，则返回原字符串让后续的 z.number() 报错
    }
    return arg;
  }, z.number({invalid_type_error: "必须是数字或数字字符串"}));

  console.log(flexibleNumberSchema.parse("123.45")); // 123.45 (数字)
  console.log(flexibleNumberSchema.parse(500));     // 500 (数字)
  // console.log(flexibleNumberSchema.safeParse("abc")); // success: false, error...

  // 示例：处理可能为 "true"/"false" 字符串的布尔值
  const booleanLikeSchema = z.preprocess(val => {
      if (typeof val === 'string') {
          if (val.toLowerCase() === 'true') return true;
          if (val.toLowerCase() === 'false') return false;
      }
      return val;
  }, z.boolean());

  console.log(booleanLikeSchema.parse("true")); // true
  console.log(booleanLikeSchema.parse("FALSE")); // false
  console.log(booleanLikeSchema.parse(true)); // true
  // console.log(booleanLikeSchema.safeParse("not a boolean")); // success: false
  ```

## pipe

+ `.pipe(outputSchema)` : 链式验证。首先用当前 schema 验证数据，如果成功，则将结果（可能是经过转换的）传递给 outputSchema 进行进一步验证和转换

  ```js
  import { z } from 'zod';

  // 步骤1: 确保输入是字符串，并转换为数字
  const stringToNumber = z.string().transform(val => parseInt(val, 10));

  // 步骤2: 确保转换后的数字是正数
  const positiveNumber = z.number().positive();

  // 使用 .pipe() 连接它们
  const stringToPositiveNumberSchema = stringToNumber.pipe(positiveNumber);
  // 等价于: z.string().transform(val => parseInt(val, 10)).pipe(z.number().positive())
  // 但更清晰的写法是分开定义

  console.log(stringToPositiveNumberSchema.parse("123")); // 123
  // stringToPositiveNumberSchema.parse("0"); // 抛出 ZodError (positiveNumber 校验失败)
  // stringToPositiveNumberSchema.parse("-10"); // 抛出 ZodError (positiveNumber 校验失败)
  // stringToPositiveNumberSchema.parse("abc"); // 抛出 ZodError (stringToNumber 校验失败，因为 parseInt("abc") 是 NaN)

  // 注意：如果 stringToNumber 内部的 transform 返回了 NaN，
  // 那么 NaN 会传递给 positiveNumber，positiveNumber 会校验失败。
  // 如果希望在 parseInt 失败时就给出明确错误，可以这样做：
  const robustStringToPositiveNumberSchema = z.string()
    .regex(/^\d+$/, "必须是纯数字字符串") // 先确保是数字字符串
    .transform(val => parseInt(val, 10))
    .pipe(z.number().positive("数字必须为正数"));

  console.log(robustStringToPositiveNumberSchema.safeParse("100")); // success: true, data: 100
  console.log(robustStringToPositiveNumberSchema.safeParse("-5"));  // success: false, (regex 失败)
  console.log(robustStringToPositiveNumberSchema.safeParse("text"));// success: false, (regex 失败)
  ```
