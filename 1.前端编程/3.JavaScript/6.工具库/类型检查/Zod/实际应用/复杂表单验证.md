# 复杂表单验证

## code

+ code

  ```js
  import { z, ZodError, ZodIssueCode } from 'zod'; // 假设使用 ES模块

  // --- 1. 定义 Zod Schema ---
  const currentYear = new Date().getFullYear();

  // 基础用户 Schema，不包含依赖于其他字段的校验
  const baseRegistrationSchema = z.object({
    username: z.string()
      .min(3, "用户名至少需要3个字符")
      .max(20, "用户名不能超过20个字符")
      .regex(/^[a-zA-Z0-9_]+$/, "用户名只能包含字母、数字和下划线"),
    email: z.string().email("无效的邮箱地址"),
    password: z.string()
      .min(8, "密码至少需要8个字符")
      .regex(/[A-Z]/, "密码必须包含至少一个大写字母")
      .regex(/[a-z]/, "密码必须包含至少一个小写字母")
      .regex(/[0-9]/, "密码必须包含至少一个数字")
      .regex(/[^A-Za-z0-9]/, "密码必须包含至少一个特殊符号"),
    confirmPassword: z.string(),
    birthYear: z.preprocess(
      (val) => (typeof val === 'string' && val.trim() !== '' ? parseInt(val, 10) : undefined),
      z.number({ invalid_type_error: "出生年份必须是数字" })
        .int("出生年份必须是整数")
        .min(currentYear - 100, `出生年份不能早于 ${currentYear - 100}`)
        .max(currentYear - 18, `您必须年满18岁 (即出生年份不晚于 ${currentYear - 18})`)
        .optional() // 使其在 preprocess 之前可以为空字符串，之后可以为 undefined
    ).or(z.literal(undefined)), // 允许完全不填，这样 preprocess 返回 undefined 时能通过
    profileType: z.enum(["PERSONAL", "BUSINESS"], {
      required_error: "请选择账户类型",
      invalid_type_error: "无效的账户类型"
    }),
    businessName: z.string().optional(), // 初始为可选
    bio: z.string()
      .max(200, "个人简介不能超过200个字符")
      .optional()
      .transform(val => val === "" ? undefined : val), // 空字符串视作未填写
    terms: z.literal(true, {
      errorMap: () => ({ message: "您必须同意服务条款" }) // 自定义特定错误
    }),
  });

  // 使用 superRefine 进行跨字段验证和条件验证
  const refinedRegistrationSchema = baseRegistrationSchema
    .superRefine((data, ctx) => {
      // 1. 密码和确认密码匹配
      if (data.password !== data.confirmPassword) {
        ctx.addIssue({
          code: ZodIssueCode.custom,
          message: "两次输入的密码不匹配",
          path: ["confirmPassword"],
        });
        // 也可以同时给 password 字段加错误，如果需要
        // ctx.addIssue({
        //   code: ZodIssueCode.custom,
        //   message: "两次输入的密码不匹配",
        //   path: ["password"],
        // });
      }

      // 2. 如果账户类型是 BUSINESS，则 businessName 是必填的
      if (data.profileType === "BUSINESS") {
        if (!data.businessName || data.businessName.trim().length < 2) {
          ctx.addIssue({
            code: ZodIssueCode.custom, // 或者 ZodIssueCode.too_small
            message: "公司名称至少需要2个字符",
            path: ["businessName"],
          });
        }
      }
    });

  // 推断 TypeScript 类型
  type RegistrationFormInput = z.input<typeof refinedRegistrationSchema>; // 获取输入类型 (parse 前)
  type RegistrationFormOutput = z.output<typeof refinedRegistrationSchema>; // 获取输出类型 (parse 后, transform 后)
  // 在这个例子中，input 和 output 类型差别不大，主要是 bio 可能从 "" 变为 undefined

  // --- 2. DOM 元素获取 ---
  const form = document.getElementById('registrationForm') as HTMLFormElement;
  const successMessageDiv = document.getElementById('successMessage') as HTMLDivElement;

  // 获取所有输入字段，以便统一处理错误显示
  const inputFieldNames: (keyof RegistrationFormInput)[] = [
    'username', 'email', 'password', 'confirmPassword', 'birthYear',
    'profileType', 'businessName', 'bio', 'terms'
  ];

  // --- 3. 事件监听与处理逻辑 ---
  form.addEventListener('submit', function(event) {
    event.preventDefault(); // 阻止表单默认提交行为
    clearAllErrors(); // 清除之前的错误信息
    successMessageDiv.textContent = ''; // 清除成功信息

    // 从表单收集数据
    const formData = new FormData(form);
    const data: Record<string, any> = {}; // 使用 Record<string, any> 更灵活
    formData.forEach((value, key) => {
      // FormData 会将 checkbox 的值转为 "on" 或 undefined (如果未勾选)
      // Zod 的 z.literal(true) 需要布尔值 true
      if (key === 'terms') {
        data[key] = (value === 'on');
      } else if (form.elements.namedItem(key) instanceof HTMLInputElement && (form.elements.namedItem(key) as HTMLInputElement).type === 'number') {
          // 对于数字输入，如果为空，FormData 可能得到空字符串
          data[key] = value === '' ? undefined : value; // 让 preprocess 处理
      }
      else {
        data[key] = value;
      }
    });

    // 对于未勾选的 checkbox，FormData 可能不会包含其键，手动设置为 false
    if (!data.hasOwnProperty('terms')) {
      data.terms = false;
    }

    console.log("表单原始数据:", data);

    // 使用 Zod 进行验证
    const validationResult = refinedRegistrationSchema.safeParse(data);

    if (validationResult.success) {
      // 验证通过
      successMessageDiv.textContent = '注册成功！数据已通过验证。';
      console.log('验证通过的数据:', validationResult.data as RegistrationFormOutput);
      // 在这里，你可以将 validationResult.data 发送到服务器
      // form.reset(); // 可以选择清空表单
    } else {
      // 验证失败，显示错误信息
      console.error('验证失败:', validationResult.error.flatten());
      displayErrors(validationResult.error);
    }
  });

  // 动态显示/隐藏公司名称字段
  const profileTypeSelect = document.getElementById('profileType') as HTMLSelectElement;
  const businessNameGroup = document.getElementById('businessNameGroup') as HTMLDivElement;

  if (profileTypeSelect && businessNameGroup) {
    profileTypeSelect.addEventListener('change', function() {
      if (this.value === 'BUSINESS') {
        businessNameGroup.style.display = 'block';
      } else {
        businessNameGroup.style.display = 'none';
        // 清空 businessName 的值和错误（如果需要）
        (document.getElementById('businessName') as HTMLInputElement).value = '';
        const businessNameErrorDiv = document.getElementById('error-businessName');
        if (businessNameErrorDiv) businessNameErrorDiv.textContent = '';
      }
    });
  }


  // --- 4. 辅助函数 ---
  function displayErrors(error: ZodError<RegistrationFormInput>) {
    const flatErrors = error.flatten(); // { formErrors: string[], fieldErrors: { [field: string]: string[] } }

    // 显示字段特定错误
    for (const field in flatErrors.fieldErrors) {
      const fieldName = field as keyof RegistrationFormInput; // 类型断言
      const errorDiv = document.getElementById(`error-${fieldName}`);
      if (errorDiv) {
        errorDiv.textContent = (flatErrors.fieldErrors[fieldName] ?? []).join(', ');
      }
    }

    // 显示表单级别错误 (如果有) - 这个例子中主要通过 path 指定到字段
    if (flatErrors.formErrors.length > 0) {
      // 可以选择一个通用的地方显示这些错误，或者附加到某个特定字段
      const generalErrorDiv = document.getElementById('error-terms') || successMessageDiv; // 借用一个地方
      if (generalErrorDiv) {
          generalErrorDiv.innerHTML += `<br/>其他错误: ${flatErrors.formErrors.join(', ')}`;
      }
    }
  }

  function clearAllErrors() {
    inputFieldNames.forEach(fieldName => {
      const errorDiv = document.getElementById(`error-${fieldName}`);
      if (errorDiv) {
        errorDiv.textContent = '';
      }
    });
  }

  // 确保在页面加载时，如果初始 profileType 是 BUSINESS，则显示 businessNameGroup
  document.addEventListener('DOMContentLoaded', () => {
    if (profileTypeSelect && profileTypeSelect.value === 'BUSINESS') {
      if (businessNameGroup) businessNameGroup.style.display = 'block';
    }
  });

  ```

## 代码讲解 (formValidation.ts) :


+ 步骤1：Schema 定义 (refinedRegistrationSchema) :

  + 我们首先定义了一个 baseRegistrationSchema，包含了对各个字段的基本类型、格式和长度的校验

    + username: 字符串，长度3-20，特定正则
    + email: 必须是 email 格式
    + password: 字符串，最小长度8，并包含大小写字母、数字和特殊符号
    + confirmPassword: 初始只是字符串，匹配校验在 superRefine 中
    + birthYear: 使用 z.preprocess 将输入的字符串（如果是数字）转为数字，然后进行年龄校验。允许为空或不填
    + profileType: 枚举类型，必须是 "PERSONAL" 或 "BUSINESS"
    + businessName: 初始为可选字符串
    + bio: 可选字符串，最大长度200。空字符串通过 transform 转为 undefined
    + terms: 必须是 true (通过 z.literal(true))，并自定义了错误消息

  + 然后，我们使用 .superRefine() 来处理跨字段的复杂校验逻辑：

    + 密码确认：检查 password 和 confirmPassword 是否一致。如果不一致，通过 ctx.addIssue 为 confirmPassword 字段添加一个自定义错误
    + 条件必填：如果 profileType 是 "BUSINESS"，则 businessName 变为必填项，并检查其长度


+ 步骤2：类型推断:

  + `RegistrationFormInput = z.input<typeof refinedRegistrationSchema>` : 推断出 Zod schema 解析之前的期望输入类型
  + `RegistrationFormOutput = z.output<typeof refinedRegistrationSchema>` : 推断出 Zod schema 解析并转换之后的输出类型。对于包含 .transform() 或 .default() 的 schema，输入和输出类型可能不同

+ 步骤3：DOM 操作与事件监听:

  + 获取表单元素和用于显示消息的 div

  + 给表单的 submit 事件添加监听器

  + 在提交时，阻止默认行为，清除旧错误

  + 数据收集: 使用 FormData 从表单收集数据。特别处理了 checkbox (需要转为布尔值) 和可能为空的 number 输入

  + 验证: 调用 refinedRegistrationSchema.safeParse(data) 进行验证

  + 结果处理:

    + 如果 validationResult.success 为 true，显示成功消息，并可以在此将 validationResult.data (类型为 RegistrationFormOutput) 发送到服务器
    + 如果为 false，调用 displayErrors 函数来显示错误

  + 动态字段显示: 根据 profileType 的选择，动态显示或隐藏 businessName 字段

+ 步骤4：错误显示与清除:

  + displayErrors(error):接收 ZodError 对象，使用 error.flatten() 来获取一个易于处理的错误结构。遍历 fieldErrors，将错误消息显示在对应字段下方的 div 中
  + clearAllErrors(): 清除所有字段的错误消息
