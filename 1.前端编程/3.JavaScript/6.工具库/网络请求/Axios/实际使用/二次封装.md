# 二次封装

## 引入

+ + 一般我会在项目的src目录中，新建一个 request 文件夹，然后在里面新建一个http.js和一个api.js文件
+ http.js文件用来封装我们的axios，api.js用来统一管理我们的接口

  ```js
  // 在http.js中引入axios
  import axios from 'axios'; // 引入axios
  import QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到
  // vant的toast提示框组件，大家可根据自己的ui组件更改。
  import { Toast } from 'vant';
  ```

## 基本全局配置

+ baseURL 、 超时时间、请求头、responseType、withCredentials(是否携带cookie)等

+ 通过axios.defaults.timeout设置默认的请求超时时间。例如超过了10s，就会告知用户当前请求超时，请刷新等

  ```js
  const request = axios.create({
    baseURL: "http://localhose:8080",
    timeout: 30 * 1000,
    responseType: "json",
    head: {
      "xxx": "",
    }
  })
  ```

## token 密钥

+ 权限和安全考虑设置到请求体

+ 这里说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态

  + 然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过

+ 这时候或许有些小伙伴会有疑问了，就是每个请求都携带token，那么要是一个页面不需要用户登录就可以访问的怎么办呢？其实，你前端的请求可以携带token，但是后台可以选择不接收啊

  ```js
  import globalConfig from "@/global.config.js"
  import store from '@/store/index';

  request.interceptors.request.use((config) => {
    // token 、 密钥

    // token 设置
    // 每次发送请求之前判断vuex中是否存在token
    // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况
    // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断
    {
      const token = store.state.token;

      // 对于不需要token验证的页面 我们增加一个白名单
      const list = globalConfig.whiteListApi;
      const url = config.url;

      // 不在白名单内
      if(!list.includes(url) && token) {
        config.headers.Authorization = token
      }



    }

    // 密钥 secretId+特殊算法
    {
      const str = globalConfig.secretId + Date.now();

      // MD5 加密



      config.headers.secret = str;
    }

    return config;
  }, error => {
    return Promise.reject(new Error(error));
  });
  ```

  ```js
  // 全局配置中心 src/global.config.js
  export default {
    // 白名单
    whiteListApi: ["/a", "/b"],

    // 密钥
    secretId: "hellowrod" // 密钥的盐
  }
  ```

## 响应的统一基本处理

+ 针对错误的情况做全局统一处理

  ```js
  import {router  }  from  "./routers"

  request.interceptors.response.use((config) => {
    // 响应的统一基本处理
    const status = res.code.code || 200;
    const message = res.code.msg || '未知错误';

    if(status === 401) {
      // 没有权限
      alert("error")
      router.push("/login");
      return Promise.reject(new Error(error)); // 兜底处理
    }

    if(status !== 200) {
      return Promise.reject(new Error(error));
    }

  }, error => {

    // 错误处理
    alert("error")

    return Promise.reject(new Error(error));
  });
  ```

## 封装请求方法

+ 把接口的请求封装为一个方法

