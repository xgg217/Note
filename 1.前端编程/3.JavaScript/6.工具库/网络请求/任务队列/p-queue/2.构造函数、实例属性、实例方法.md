# PQueue

## 构造函数 PQueue(options?)

+ 传入一个object对象，返回一个对象实例

+ `new PQueue(options?)`

+ options

  + concurrency：并发数量，number类型，最小为1，最大无限制
  + timeout: 定义超时时间，单位毫秒 默认 undefined

    ```js
    const queue = new PQueue({timeout: 5000});

    // This task uses the global 5s timeout
    await queue.add(() => fetchData());

    // This task has a 10s timeout
    await queue.add(() => slowTask(), {timeout: 10000});
    ```

  + autoStart：当add后是否自动开始，默认为true
  + queueClass Function 类型
  + intervalCap：给定时间间隔内的最大运行次数，number类型
  + interval：定义间隔时间，单位毫秒
  + carryoverConcurrencyCount：是否将间隔时间未完成的任务进入下一间隔，默认false
  + throwOnTimeout：超时是否被视为异常，默认false
  + carryoverIntervalCount 是否将间隔时间未完成的任务进入下一间隔，默认false

+ 返回值 queue

## 实例属性

+ .size 等待任务数
+ .pending 正在执行任务数
+ .timeout
+ .isPaused 是否暂停
+ .isRateLimited
+ .isSaturated
+ .runningTasks 目前正在执行的任务

## 实例方法

+ .add(fn, options?) 向队列添加同步或异步任务

  + fn

    + 执行时，它将作为第一个参数接收。{signal}

  + options

    + priority 优先级，number类型，数值越大优先级越高 默认0
    + id
    + signal

  ```js
  // priority 优先级
  const queue = new PQueue({
    concurrency: 2
  });

  // 高优先级任务
  queue.add(() => importantTask(), { priority: 1 });

  // 低优先级任务
  queue.add(() => backgroundTask(), { priority: 10 });
  ```

  ```js
  // 取消
  import PQueue from 'p-queue';
  import got, {CancelError} from 'got';

  const queue = new PQueue();

  const controller = new AbortController();

  try {
    await queue.add(({signal}) => {
      const request = got('https://sindresorhus.com');

      signal.addEventListener('abort', () => {
        request.cancel();
      });

      try {
        return await request;
      } catch (error) {
        if (!(error instanceof CancelError)) {
          throw error;
        }
      }
    }, {signal: controller.signal});
  } catch (error) {
    if (!(error instanceof DOMException)) {
      throw error;
    }
  }
  ```

+ .addAll(fns, options?)
+ .pause() 暂停
+ .start() 恢复执行
+ .onEmpty() 当队列成为空的时候，返回一个promise
+ .onIdle() 当队列成为空并且所有的任务都执行完的时候，返回一个promise

  + 与onEmpty()不同点在于保证所有任务都执行完了，即 `queue.size === 0 && queue.pending === 0`
  + onEmpty是队列成为空，但是promise不一定已经执行完了

+ .onPendingZero()

  + 当所有当前正在运行的任务都完成时 queue.pending === 0
  + 忽略排队任务

+ .onRateLimit()
+ .onRateLimitCleared()
+ .onError()
+ .onSizeLessThan(limit)
+ .clear() 清空队列（移除所有排队任务）

  + 会触发 `onIdle`

+ .sizeBy(options)
+ .setPriority(id, priority)
