# TS

## TS类型

+ 类型

  ```js
  function watchEffect(
    effect: (onCleanup: OnCleanup) => void,
    options?: WatchEffectOptions
  ): WatchHandle

  type OnCleanup = (cleanupFn: () => void) => void

  interface WatchEffectOptions {
    flush?: 'pre' | 'post' | 'sync' // 默认：'pre'
    onTrack?: (event: DebuggerEvent) => void
    onTrigger?: (event: DebuggerEvent) => void
  }
  // flush
    'pre' // 侦听器将在组件渲染之前执行
    'post' // 将会使侦听器延迟到组件渲染之后再执行
    'sync' // 响应式依赖发生改变时立即触发侦听器


  interface WatchHandle {
    (): void // 可调用，与 `stop` 相同
    pause: () => void // 暂停侦听器
    resume: () => void // 稍后恢复
    stop: () => void // 停止
  }
  ```

+ 暂停/恢复侦听器

  ```js
  const { stop, pause, resume } = watchEffect(() => {});

  // 暂停侦听器
  pause()

  // 稍后恢复
  resume()

  // 停止
  stop()
  ```

+ 副作用清理：

  ```js
  import { onWatcherCleanup } from 'vue'

  watchEffect(async () => {
    const { response, cancel } = doAsyncWork(newId)
    // 如果 `id` 变化，则调用 `cancel`，
    // 如果之前的请求未完成，则取消该请求
    onWatcherCleanup(cancel)
    data.value = await response
  })
  ```

## 回调触发的时机

+ 默认情况下，侦听器回调的执行时机在父组件更新 之后，所属组件的 DOM 更新 之前 被调用
+ 这意味着如果你尝试在回调函数中访问所属组件的 DOM，拿到的是 DOM 更新之前的状态

  ```html
  <template>
    <div>
      <button @click="isShow = !isShow">显示/隐藏</button>
      <div v-if="isShow" ref="divRef">
        <p>this is a test</p>
      </div>
      <p>上面的高度为：{{ height }} pixels</p>
    </div>
  </template>

  <script setup>
  import { ref, watch } from 'vue'
  const isShow = ref(false)
  const height = ref(0) // 存储高度
  const divRef = ref(null) // 获取元素

  watch(isShow, () => {
    // 获取高度，将高度值给 height
    height.value = divRef.value ? divRef.value.offsetHeight : 0
    console.log(`当前获取的高度为：${height.value}`)
  })
  </script>
  ```

+ 如果我们期望侦听器的回调在 DOM 更新之后再被调用，那么可以将第三个参数 `flush` 设置为 `post` 即可

  ```js
  watch(
    isShow,
    () => {
      // 获取高度，将高度值给 height
      height.value = divRef.value ? divRef.value.offsetHeight : 0
      console.log(`当前获取的高度为：${height.value}`)
    },
    {
      flush: 'post'
    }
  )
  ```


