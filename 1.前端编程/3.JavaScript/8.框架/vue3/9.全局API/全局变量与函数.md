# 全局对象

## 无法访问

+ 无法访问到

  ```html
  <template>
    <div>{{ Test.a }}</div>
  </template>

  <script setup>
  window.Test = {
    a: 1
  }
  </script>

  // 会报错：Cannot read properties of undefined (reading 'a')
  ```

## app.config.globalProperties

+ 一个用于注册能够被应用内所有组件实例访问到的全局属性的对象
+ 需要在 window 上挂载一个全局对象供模板访问，可以使用 `app.config.globalProperties`
+ 如果全局属性与组件自己的属性冲突，组件自己的属性将具有更高的优先级

  ```js
  // main.js

  import { createApp } from 'vue'
  // 引入了根组件
  import App from './App.vue'

  // 挂载根组件
  const app = createApp(App)

  // 在这里新增全局对象属性
  app.config.globalProperties.Test = {
    a: 'Hello, Global Object!'
  }

  app.config.globalProperties.$msg = 'hello'

  app.mount('#app')
  ```

+ 在应用的任意组件模板上都可用，并且也可以通过任意组件实例的 this 访问到

  ```html
  <!-- 模板中可以直接使用 -->
  <div>{{ $msg }}</div>
  ```

  ```js
  // 选项式使用 this.
  export default {
    mounted() {
      console.log(this.$msg) // 'hello'
    }
  }
  ```

  ```js
  import { getCurrentInstance } from 'vue';
  const { proxy } = getCurrentInstance();

  console.log(proxy.$msg);
  ```

## ts

+ 若是项目使用了TypeScript，需要给新增的全局属性补充类型声明，否则在使用时ts会报错

+ 创建一个.d.ts文件，并确认该文件的路径是在tsconfig.json中include对象内配置过的，即可以被ts检测到。（文件可以根据需求命名，此处命名为 global-properties.d.ts）

  ```js
  import { ComponentCustomProperties } from "@vue/runtime-core";

  declare module '@vue/runtime-core' {
    // 根据新增加的属性 追加类型声明
    interface ComponentCustomProperties {
      $addValue(value: number): number;
      $globalValue: string;
    }
  }
  ```

+ 使用

  ```js
  // getCurrentInstance获取当前组件实例的上下文信息
  import { getCurrentInstance } from "vue"
  // 表示当前组件实例的类型
  import type { ComponentInternalInstance } from "vue"
  // 获取proxy属性 可以访问挂载在全局的实例和方法(需要断言 否则ts报错)
  const { proxy } = getCurrentInstance() as ComponentInternalInstance;

  // 使用全局方法和变量(因proxy可能为null 若不使用?. ts会报错)
  console.log(proxy?.$addValue(2))     // 859
  console.log(proxy?.$globalValue)     // 我是全局变量
  ```
