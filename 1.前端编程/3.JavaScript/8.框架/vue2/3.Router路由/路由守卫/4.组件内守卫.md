# 组件内守卫

## 作用

+ 是指在组件内执行的钩子函数，类似于组件内的生命周期，相当于为配置路由的组件添加的生命周期钩子函数

## beforeRouteEnter

+ 路由进入之前调用

+ 在该守卫内访问不到组件的实例，`this` 值为 `undefined`

+ 在这个钩子函数中，可以通过传一个回调给 `next` 来访问组件实例

+ 在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数，可以在这个守卫中请求服务端获取数据，当成功获取并能进入路由时，调用 `next` 并在回调中通过 vm访问组件实例进行赋值等操作，（ `next` 中函数的调用在 `mounted` 之后：为了确保能对组件实例的完整访问）

  ```js
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建

    next( vm => {
      // 通过 `vm` 访问组件实例
    })
  },
  ```

## beforeRouteUpdate

+ 在当前路由改变时，并且该组件被复用时调用，可以通过 `this` 访问实例

+ 何时组件会被复用？

  + 动态路由间互相跳转

  + 路由 `query` 变更

    ```js
    beforeRouteUpdate (to, from, next) {
      // 在当前路由改变，但是该组件被复用时调用
      // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
      // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用
      // 可以访问组件实例 `this`
    },
    ```

## beforeRouteLeave

+ 导航离开该组件的对应路由时调用，可以访问组件实例 `this`

  ```js
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
  ```
