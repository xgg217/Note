# 基础

## 优化项

+ 使用key
+ 使用冻结的对象
+ 使用函数式组件
+ 使用计算属性
+ 非实时绑定表单项
+ 保持对象引用稳定
+ 使用 v-show 替代 v-if
+ 使用延迟装载（defer）
+ 使用keep-alive
+ 长列表优化

## 使用key

+ 对于通过循环生成的列表，应给每个列表一个稳定且唯一的 key
+ 这有利于在列表变动时，尽量少的删除和新增元素

## 使用冻结的对象

+ 冻结的对象（或者数组）不会被响应

  ```js
  const obj = {
    a: 1,
    b: 2
  }

  Object.freeze(obj)

  // 不能改变属性
  obj.a = 3
  obj.a // 1
  ```

## 使用函数式组件

+ 参见[函数式组件](https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6)

## 使用计算属性

+ 如果模板中某个数据会使用多次，并且该数据是通过计算得到的，使用计算属性以缓存它们

## 非实时绑定表单项

+ 当使用 `v-model` 绑定一个表单项时，当用户改变表单项的状态时，也会随之改变数据，从而导致vue发生重渲染（rerender），这会带来一些性能的开销。

+ 特别是当用户改变表单项时，页面有一些动画正在进行中，由于JS执行线程和浏览器渲染线程是互斥的，最终会导致动画出现卡顿。

+ 我们可以通过使用 `lazy` 或不使用 `v-model` 的方式解决该问题，但要注意，这样可能会导致在某一个时间段内数据和表单项的值是不一致的。

## 保持对象引用稳定

+ 在绝大部分情况下，vue触发rerender的时机是其依赖的数据发生变化

+ 若数据没有发生变化，哪怕给数据重新赋值了，vue也是不会做出任何处理的

+ 下面是vue判断数据没有变化的 **源码**

  ```js
  // value 为旧值， newVal 为新值
  if (newVal === value || (newVal !== newVal && value !== value)) {
    return
  }
  ```

+ 因此，如果需要，只要能保证组件的依赖数据不发生变化，组件就不会重新渲染。

+ 对于原始数据类型，保持其值不变即可

+ 对于对象类型，保持其引用不变即可

+ 从另一方面来说，由于可以通过保持属性引用稳定来避免子组件的重渲染，那么我们应该细分组件来尽量避免多余的渲染

## 使用 v-show 替代 v-if

+ 对于频繁切换显示状态的元素，使用v-show可以保证虚拟dom树的稳定，避免频繁的新增和删除元素，特别是对于那些内部包含大量dom元素的节点，这一点极其重要

+ **关键字**：频繁切换显示状态、内部包含大量dom元素

## 使用延迟装载（defer）

+ 首页白屏时间主要受到两个因素的影响：

  + 打包体积过大:巨型包需要消耗大量的传输时间，导致JS传输完成前页面只有一个 `<div>` ，没有可显示的内容

  + 需要立即渲染的内容太多:JS传输完成后，浏览器开始执行JS构造页面。但可能一开始要渲染的组件太多，不仅JS执行的时间很长，而且执行完后浏览器要渲染的元素过多，从而导致页面白屏

+ 打包体积过大需要自行优化打包体积

+ 一个可行的办法就是延迟装载组件，让组件按照指定的先后顺序依次一个一个渲染出来

+ 延迟装载是一个思路，本质上就是利用 `requestAnimationFrame` 事件分批渲染内容，它的具体实现多种多样
