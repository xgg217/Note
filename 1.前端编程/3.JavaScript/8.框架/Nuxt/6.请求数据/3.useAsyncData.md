# useAsyncData

## 概述

+ 如果想要避免重复请求的情况，可以使用 useAsyncData，这是一个 Nuxt 内置的组合式函数，数据仅在服务器端请求一次，然后会有缓存，可以有效避免客户端的重复请求
+ 基础语法如下：

  ```html
  <script setup lang="ts">
  const { data, status, error, refresh, clear } = await useAsyncData(
    'mountains',
    () => $fetch('https://api.nuxtjs.dev/mountains')
  )
  </script>
  ```

## API

+ 定义

  ```js
  // 定义一:
  function useAsyncData(
    handler: (nuxtApp?: NuxtApp) => Promise<DataT>,
    options?: AsyncDataOptions<DataT>
  ): AsyncData<DataT>

  // 定义二:
  function useAsyncData(
    key: string,
    handler: (nuxtApp?: NuxtApp) => Promise<DataT>,
    options?: AsyncDataOptions<DataT>
  ): Promise<AsyncData<DataT>>
  ```

  ```js
  // 两个主要区别就是一个没有key,一个有key
  // 可选参数的类型定义
  type AsyncDataOptions<DataT> = {
    server?: boolean
    lazy?: boolean
    default?: () => DataT | Ref<DataT> | null
    transform?: (input: DataT) => DataT
    pick?: string[]
    watch?: WatchSource[]
    immediate?: boolean
  }
  ```

+ 参数：

  + key：为 useAsyncData 提供一个唯一标识符

    + Nuxt 根据提供的 key 检查是否已有缓存
    + 如果缓存存在且有效，直接返回缓存数据
    + 如果没有缓存或缓存失效，则调用 fetcher 函数获取数据

  + fetcher 函数：定义如何获取数据

  + options 可选

    + lazy: 是否在页面加载之后再等待执行异步任务，默认为false，表示在页面加载之前会阻塞，直到异步任务执行完。
    + default: 一个工厂方法, 在异步任务还未执行完时，生成一个默认的返回的数据,
    + server: 默认为true, 表示是会在服务器去执行异步任务获取数据
    + pick: 数组类型，表示只从异步任务返回数据之前，选择指定的数据返回

      + 例如:

        ```js
        // 接口实际返回的数据 {"title":"dkdkkd", "description":"dkjskdjs", "other":"dksjdksj"}
        const { data: mountain } = await useFetch('/api/mountains/everest', { pick: ['title', 'description'] })
        ```

    ```html
    <template>
      <div>App page</div>
    </template>
    <script setup>
    const { data } = await useAsyncData("userList", () =>
      $fetch("http://localhost:7001/users")
    );
    console.log(data.value);
    </script>
    ```

+ 返回值

  data: 异步任务返回的数据

    + 服务端在返回这个data的同时，会将data数据序列化并存放在payload里，payload和已经 渲染好的html文本一起发送给浏览器
    + 在客户端(浏览器)第一次加载页面执行这个方法的时候，并不会真正的等待执行异步任务，而是先检查payload中是否已经存在此数据，如果存在则直接返回payload中的数据。这样客户端不用再次请求接口，而是直接拿到服务端已经请求过的数据
    + 然后在客户端切换路由过程中再次加载此页面时，会等待执行异步任务，此时data里是最新的数据

  + pending: boolean值，标识当前数据是否获取到了

  + refresh/execute: 此返回值是一个函数对象，调用时会两次执行handler中的异步任务并更新data中的数据

  + error: 包含获取失败信息的对象

  ```js
  // 返回数据类型定义
  interface RefreshOptions {
    dedupe?: boolean
  }

  type AsyncData<DataT, ErrorT> = {
    data: Ref<DataT | null>
    pending: Ref<boolean>
    execute: () => Promise<void>
    refresh: (opts?: RefreshOptions) => Promise<void>
    error: Ref<ErrorT | null>
  }
  ```


## 第三个参数

+ useAsyncData 还接收第三个参数

  + 这个参数是一个配置对象，你可以在 官方文档 中看到该配置对象支持的所有配置项
  + 其中有一个就是 lazy
  + 如果 lazy 项设置为 `true` ，这意味着导航不会等待数据获取完成，页面会立即渲染，数据获取在后台进行

  ```html
  <template>
    <div v-if="pending">加载中...</div>
    <div v-else-if="error">加载失败:{{ error.message }}</div>
    <div v-else>数据：{{ data }}</div>
  </template>

  <script setup>
  const { data, pending, error } = await useAsyncData(
    "unique-key",
    () => new Promise((resolve) => setTimeout(() => resolve("模拟数据"), 5000)),
    {
      lazy: false,
      // 默认其实就是 false
    }
  );
  </script>
  ```

+ 在初始 SSR 的时候，useAsyncData 会在服务器等待数据获取完成后再渲染页面。这样服务器生成的 html 是包含数据的，但是这也意味着服务器端在渲染首屏 html 的时候需要等待请求的时间

