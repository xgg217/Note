# 混合渲染

## 概述

+ 可以为一组 Nuxt 路由定义特定的规则，这包括改变一些路由的渲染模式或分配特定的缓存策略，从而决定服务器如何响应针对该 URL 的请求。

+ 场景示例：

  + 假设一个内容网站，其中大部分页面（如文章页面）都是静态内容，只需要在构建时生成一次，然后长期缓存；而网站的管理后台则需要用户登录、实时更新数据，必须每次都动态渲染。

+ 通过混合渲染和路由规则，可以为文章页面设置缓存策略，让它们在构建时生成静态 HTML，同时为管理后台页面指定不缓存、每次请求都动态渲染。这样既保证了普通内容页面的加载速度和 SEO 优势，又满足了后台动态交互的需求。

+ 具体配置示例：

  ```js
  export default defineNuxtConfig({
    routeRules: {
      // 将首页在构建时预渲染（prerender）
      // 构建时生成静态 HTML，之后所有访问该路由的请求都直接返回这份预渲染好的内容，不再进行动态渲染。
      // 这种方式适用于内容稳定且无需频繁更新的页面，有助于提高首屏加载速度和 SEO 表现。
      '/': { prerender: true },

      // Products 页面使用 SWR（Stale-While-Revalidate）策略
      // 该页面在请求时会先返回缓存（即使数据已经“过时”），同时在后台重新获取最新数据，并在获取完成后更新缓存。
      // 使用 true 表示采用默认的 SWR 策略，适用于数据可能变化但允许短暂显示缓存数据的场景。
      '/products': { swr: true },

      // 所有以 /products/ 开头的子路由页面也使用 SWR 策略，但缓存时间设置为 3600 秒（即 1 小时）。
      // 对于产品详情等子页面，当用户访问时，若有缓存数据则直接返回，同时后台重新验证并更新数据。
      // 数值 3600 表示缓存有效期为 1 小时，适用于数据更新频率较低，但又希望保持一定的实时性页面。
      '/products/**': { swr: 3600 },

      // Blog 主页使用 ISR（Incremental Static Regeneration）模式，缓存时间 3600 秒。
      // 该页面在首次请求时会生成静态 HTML，并在后台以 ISR 模式定期重新生成（每 1 小时）。
      // 这样既享有静态页面的加载速度，又能定期更新数据。适合新闻、博客列表等内容更新频率较低的页面。
      '/blog': { isr: 3600 },

      // 所有以 /blog/ 开头的子路由（比如单篇博客文章）使用 ISR 模式，但只在首次请求时生成静态页面，之后直到下次部署前都不重新生成。
      // 设置为 true 表示对这些页面进行一次性生成静态 HTML，之后不再更新（或说直到下一次部署时才重新生成）。
      // 这适用于博客文章内容固定不变的场景，可以极大提升缓存和分发效率。
      '/blog/**': { isr: true },

      // 所有以 /admin/ 开头的路由禁用 SSR，即仅在客户端渲染。
      // 管理后台通常需要用户身份验证和实时交互，因此不适合预渲染。
      // 设置 ssr: false 后，这部分页面会完全在客户端运行，避免了服务器端生成静态内容，从而确保动态交互的实时性和安全性。
      '/admin/**': { ssr: false },

      // 所有以 /api/ 开头的路由自动添加 CORS（跨域资源共享）头部。
      // 对于 API 接口，通常需要允许跨域访问。
      // 配置 cors: true 后，Nuxt 服务器会自动在响应中添加相应的 CORS 头，以满足跨域请求的要求。
      '/api/**': { cors: true },

      // 将旧的 URL 重定向到新的 URL。
      // 当用户访问 /old-page 时，服务器会自动将请求重定向到 /new-page。
      // 这对于旧链接的维护和 SEO 友好性非常有用，可以避免用户访问无效页面。
      '/old-page': { redirect: '/new-page' }
    }
  })
  ```

+ 关于更详尽的路由规则，可以参阅 官方文档 https://nuxt.com/docs/guide/concepts/rendering#route-rules
