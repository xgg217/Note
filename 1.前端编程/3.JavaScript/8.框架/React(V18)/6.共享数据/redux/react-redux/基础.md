# 基础

## React-redux

+ 安装

  ```js
  yarn add react-redux
  ```

  ```js
  npm install --save react-redux

  // 如果使用ts 还需要下载 @types/react-redux
  yarn add @types/react-redux
  ```

## 作用

+ 连接 `redux` 和 `react`

## 组件

+ `Provider` 组件：没有任何UI 界面，该组件的作用是将 `redux` 的仓库放到上下文中

+ `connect`: 高阶组件，用于连接仓库和组件的

## provider 组件

+ 代码示例

  ```js
  import React from 'react';
  import { Provider } from 'react-redux'
  import stors from './redux/index'

  function App() {
    return (
      <Provider store={ stors }>
        <div className="App">
          1
        </div>
      </Provider>
    );
  }

  export default App;
  ```

## connect

+ 高阶组件

+ `connect` 组将的数据来自仓库

+ 参数1(`mapStateToProps`)：传入状态，如果没有可以传入 `null`

  + 参数1(`state`): 整个仓库的状态

  + 参数2(`ownProps`): 组件外部传来的属性值

+ 参数2：传入事件

  + 情况1：传递一个函数 `mapDispatchToProps`

    + 参数1：`dipatch`

    + 参数2：使用者传递的属性对象

    + 函数返回的对象会作为属性传递到展示组件中

        ```js
        /**
         * 映射事件处理函数
        * @param {*} dispatch
        */
        function mapDispatchToProps(dispatch) {
          return {
            onAsyncDecrease() {
              console.log('异步减')
            },
            onDecrease(id) {
              console.log('减')
              dispatch(createDelUserAction(id));
            },
            onIncrease() {
              console.log('加')
              dispatch(createAddUserAction())
            },
            onAsyncIncrease() {
              console.log('异步加')
              dispatch(fecths())
            }
          }
        }
        ```

  + 情况2：传递一个对象，对象的每个属性是一个函数，他会自动的将对象里面的函数名对应到展示组件的属性中，但是功能做出一点改变，到调用这些处理函数时，会自动 `dispath` 函数返回的 `action`

+ 示例

  ```js
  import { connect } from 'react-redux';
  import { createAddUserAction, createDelUserAction, fecths } from './../redux/action/usersAction'

  /**
   * 将仓库的状态映射到当前数据中
  * @param {*} state
  */
  function mapStateToProps(state, ownProps) {
    return {
      name: state.users
    }
  }

  /**
   * 映射事件处理函数
  * @param {*} dispatch
  */
  function mapDispatchToProps(dispatch) {
    return {
      onAsyncDecrease() {
        console.log('异步减')
      },
      onDecrease(id) {
        console.log('减')
        dispatch(createDelUserAction(id));
      },
      onIncrease() {
        console.log('加')
        dispatch(createAddUserAction())
      },
      onAsyncIncrease() {
        console.log('异步加')
        dispatch(fecths())
      }
    }
  }

  // 展示组件
  function Counter({ name, onAsyncDecrease, onDecrease, onIncrease,   onAsyncIncsrease }) {
    // console.log(props)
    // console.log(eventHandles)
    const onDecreases = (id) => {
      onDecrease(id);
    }
    return (
      <div>
        <h1>{ name[0].name }</h1>
        <div onClick={ onAsyncDecrease }>异步减</div>
        <div onClick={ () => { onDecreases(12) } }>减</div>
        <div onClick={ onIncrease }>加</div>
        <div onClick={ onAsyncIncsrease }>异步加</div>
      </div>
    )
  }

  // 返回一个高阶组将
  const hoc = connect(mapStateToProps, mapDispatchToProps);
  // 传入展示组将，返回一个容器组件
  export default hoc(Counter);
  ```

+ 细节1：如果对返回的容器组件加上额外的属性，则这些属性会直接传递到展示组将

+ 细节2：如果不传递第二个参数，通过 connect 连接的组件，会自动得到一个属性 `dispatch` 。但是不建议使用
