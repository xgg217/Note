# 路由信息

## 基础

+ Router 组件会创建一个上下文，并且向上下文中注入一些信息

+ 该上下文对开发者是隐藏的， Route 组件若能匹配到了地址，则会将这些上下文中的信息作为属性传入对应的属性

+ 属性

  + `history`

  + `location`

  + `match`

## history

+ 他并不是  `window.histroy` 对象

  + 因为 React-Router 中有两种模式（`Hash` 和 `History`）。`window.histroy` 仅支持 `History` 模式，不支持 `Hash` 模式

  + 当使用 `window.histroy.pushState` 方法时，React 没有办法监听到地址发生变化，结果导致无法重新渲染新的组件

+ 功能：无刷新跳转。`this.props.history.push('/b')`

  ```jsx
  function A(props) {
    return (<>
      <button onClick={() => {
        props.history.push('/b')
      }}>跳转到B</button>
      <h2>AAA</h2>
    </>)
  }
  ```

+ 属性 `push`: 将某个新页面的地址入栈（历史记录栈）

  + 参数1：新的地址

      ```jsx
      props.history.push('/b')
      ```

  + 参数2：状态数据

      ```jsx
      // 设置数据
      props.history.push('/b', '状态数据')
      props.history.push('/b', {a:1, b: 2})

      // 获取数据
      props.location.state;
      ```

    ```jsx
    // 错误使用
    props.history.push('https://www.baidu.com/');

    // 解决办法1
    <a href="https://www.baidu.com/"></a>

    // 解决办法2
    window.location.href = "https://www.baidu.com/";
    ```

+ 属性 `replace` : 将某个新的地址替换当前栈中的地址

+ 属性 `go` ：`window.histroy` 用法一致

+ 属性 `forward` ：`window.histroy` 用法一致

+ 属性 `back` ：`window.histroy` 用法一致

+ 属性 `listen` ：添加一个监听器，监听地址的变化。当地址发生变化时，会用传递的函数

  ```jsx
  componentDidMount() {
    this.props.history.listen((location, action) => {
      console.log('地址变化了')
      console.log(location)
      console.log(action)
    })
  }
  ```

  + 参数：函数（运行的时间点：发生在即将跳转到新页面时）

    + 参数1：`location` 对象。记录当前（新页面）的地址信息

    + 参数2：`action` 字符串。表示进入该地址的方式。返回 `POP`(出栈：栈中的指针移动)、 `PUSH`（入栈：新页面进来） `REPLACE`（替换）

      + POP：

          1. 通过点击浏览器后退按钮、前进

          2. 调用 `props.history.go()`

          3. 调用 `props.history.goBack()`

          4. 调用 `props.history.goForward()`

      + PUSH

        + 点击 `Link` 或者 `NavLink`

        + 调用 `props.history.push()`

      + REPLACE

        + 调用 `props.history.replace()`

        + 点击 `<Link replace>` 或者 `<NavLink replace>`

  + 返回结果：函数，可以调用该函数取消监听

    + 组件卸载时，取消监听

    + 主动取消监听

    ```jsx
    // 父组件
    let addCal = 0;

    const jtFunc = function(prevLocation, location, action, unxz) {
      console.log(`从${prevLocation.pathname}页面，跳转到${location.pathname}页面，跳转方式${action}`)
      if(addCal >= 5) {
        console.log('不监听你了');
        unxz(); // 取消监听
      }
    }

    function App() {
      return (
        <Router>
          <Link to="/">page1</Link>
          <Link replace to="/page2">page2</Link>

          <RouteGuard onChange={ jtFunc }>
            <p>{ addCal }</p>
            <Switch>
              <Route path="/" exact component={ Page1 }></Route>
              <Route path="/page2" exact component={ Page2 }></Route>
              <Redirect to='/'></Redirect>
            </Switch>
          </RouteGuard>
        </Router>
      );
    }
    ```

    ```jsx
    // 子组件
    import React, { PureComponent } from 'react'

    import { withRouter } from 'react-router-dom';

    class RouteGuard extends PureComponent {

      constructor(props) {
        super(props);
        this.unxz = ''
      }

      componentDidMount() {
        this.unxz = this.props.history.listen((location, action) => {

          if(this.props.onChange) {
            this.props.onChange(this.props.location, location, action, this.unxz);
          }
        })
      }

      componentWillUnmount() {
        // 卸载监听
        this.unxz();
      }

      render() {
        // console.log(this.props)
        return this.props.children;
      }
    }

    export default withRouter(RouteGuard)
    ```

+ 属性 `block` ：设置一个阻塞，并同时设置一个阻塞消息。当页面发生跳转时，会进入阻塞，并且将消息传递到**路由根组件** 的 `getUserConfirmation` 方法

## location

+ `props.location` 对象中记录了当前地址的相关信息

+ `props.history.location` === `props.location`。是同一个对象。但是与 `window.location` 不同

+ 属性 `hash`

+ 属性 `pathname` 当前路径

+ 属性 `search`

+ 属性 `state` 状态

  ```jsx
  http://localhost:3000/b?a=1&b=2#ffff

  hash-->     "#ffff"
  pathname--> "/b"
  search-->   "?a=1&b=2"
  state -->   undefined
  ```

## match

+ `props.match` 对象中保存了路由匹配的相关信息

+ 属性 `isExact` ：

  + 与 `<Route path="/a" exact component={ A }></Route>` 中的 `exzct` 没有直接关系

  + 表示当前路径和路由配置的路径是否是精确的

      ```jsx
      // 路由配置
      <Switch>
        <Route path="/a" component={ A }></Route>
        <Route path="/b" component={ B }></Route>
        <Route path="/c" component={ C }></Route>
      </Switch>

      地址是 '/b'
      props.match.isExact = true

      地址 '/b/c?a=1&b=2#ffff'
      props.match.isExact = false
      ```

+ 属性 `params` 获取路径规则中的数据 **重点**

  + 设置页面数据传递 `<Route path="/a/:year/:month/:day" component={ A }></Route>`

  + 设置部分数据为可选值 `<Route path="/a/:year?/:month?/:day?" component={ A }></Route>`

  + 设置最后一个为容易内容 `<Route path="/a/:year/:month/:day/*" exact component={ A }></Route>`

      ```js
      // 路由配置设置
      <Route path="/a/:year/:month/:day" component={ A }></Route>

      // 跳转添加数据
      props.history.push('/a/2018/09/12');

      // 获取设置
      props.math.params = {
        year: '2018',
        month: '09',
        day: '12'
      };
      ```

+ 属性 `path`

+ 属性 `url`

## 向页面传输数据的方式

1. 使用 `state` ，在 `push` 加入 `state`。该数据不在地址栏中显示

    ```jsx
    props.history.push('/b', '状态数据');
    props.history.push('/b', {a:1, b: 2});
    ```

2. 利用 `search`: 把数据填写到 ？ 后面 **推荐**

    ```jsx
    // 设置
    props.history.push('/c?a=1&b=10#f1');

    // 获取
    props.location.search
    ```

3. 利用 `hash`

4. `params` ：把数据填写到路径中 **推荐**

    ```jsx
    // 路由配置设置
    <Route path="/a/:year/:month/:day" component={ A }></Route>

    // 跳转添加数据
    props.history.push('/a/2018/09/12');

    // 获取设置
    props.math.params = {
      year: '2018',
      month: '09',
      day: '12'
    };
    ```

## 非路由组件获取路由信息

+ 所有的 路由信息 只有个在 Route 中 才能使用

  ```jsx
  <Route path="/b" component={ B }></Route>

  // 只有组件 B 才能获取到 路由信息

  function B(props) {
    console.log(props); //返回路由信息
    return (<>
      <BBaa />
    </>)
  }

  function BBaa(props) {
    console.log(props); // 无法获取到路由信息 {}
    return <button>点击返回首页</button>
  }
  ```

+ 解决方法1：从父组件把路由信息向下传递。适合嵌套层数少时使用

  ```jsx
  function B(props) {
    console.log(props); //返回路由信息
    return (<>
      <BBaa {...props} />
    </>)
  }
  ```

+ 解决方法2：使用高阶组件 `withRouter`，来包装要使用的组件。`withRouter` 组件会返回一个新组件，新组件将向提供的组件注入路由信息

  ```jsx
  import { BrowserRouter as Router,
    Route,
    Switch,
  withRouter } from 'react-router-dom'

  const NewBBaa = withRouter(BBaa); // 使用高阶函数

  function B(props) {
    console.log(props); //返回路由信息
    return (<>
      <NewBBaa />
      <h2>BBB{ props.location.state }</h2>
    </>)
  }

  function BBaa(props) {
    console.log(props); // 返回路由信息
    return <button onClick={() => {

    }}>点击返回首页</button>
  }
  ```
