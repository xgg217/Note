# 对比更新

## 对比过程

+ 将新产生的节点，对比之前虚拟 DOM 中的节点，发现差异，完成更新

## 然后对比之前 DOM 树中的那个节点

+ React 为了提交对比效率做出如下假设：

    1. 假设节点不会出现层次的移动（对比时，直接找到旧树中对应位置的节点进行对比

    2. 不同的节点类型会生成不同的结构

    3. 多个兄弟节点通过唯一标识（`key`）来确定对比的新节点

## 是否找到对比目标

+ 找到了对比目标

    1. 判断节点类型**是否一致**

        1. 相同的的节点类型

            1. 节点本身类型相同

            2. 如果是由 React 元素生成，`type` 值还必须一致

        2. 其他的都属于不相同的节点类型

+ 没有找到对比目标

+ 创建新加入的节点

+ 卸载多余的旧节点

## 节点类型是否一致

1. 节点类型一样：根据不同的节点类型，做不同的事情

    1. 空节点：不做任何事情

    2. DOM 节点：直接使用之前 DOM 对象

        1. 直接重用之前的真实 DOM 对象

        2. 将其属性变化记录下来，以待将来统一完成更新（现在还不会真正的变化）

        3. 遍历新的 React 元素的子元素，**递归对比更新**

    3. 文本节点：直接重用之前真实的 DOM 对象。将其属性变化记录下来，以待将来统一完成更新（现在还不会真正的变化）

    4. 函数组件：直接重新调用函数，得到一个节点对象，进入，对比**递归对比更新**

    5. 类组件

        1. 重用之前的组件实例

        2. 调用生命周期方法 `static getDerivedStateFromProps`

        3. 调用生命周期方法 `shouldComponentUpdate`，如果该函数返回 `false`，终止当前流程

        4. 运行 `render` 函数，得到一个**新的节点**，进入新的节点的**对比更新**

        5. 将生命周期函数 `getSnapshotBeforeUpdate` 加入执行队列中，以待将来执行

        6. 将生命周期函数 `componentDidUpdate` 加入执行队列，以待将来执行

    6. 数组节点：遍历数组，进行**递归对比更新**

2. 节点类型不一样

    1. 整体上，卸载旧的节点，创建新的节点

    2. 如果是**文本节点**、**DOM 节点**、 **数组节点**、**空节点**、**函数组件节点**：直接放弃该节点，如果节点有子节点，递归卸载节点

    3. 如果是**类组件节点**：

        1. 直接放弃该节点

        2. 调用用该节点的 `componentWillUnmount` 函数

        3. 递归卸载子节点（先卸载父节点，再卸载子节点）

## 卸载与挂载

1. 创建新节点

2. 卸载旧节
