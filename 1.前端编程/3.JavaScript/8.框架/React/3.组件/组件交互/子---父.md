# 子-->父

## 子组件事件向上传递

+ 在父组件设置一个函数，然后传递给子组件（如果存在多级嵌套组件，也是这样一层一层向下传递的）

  ```js
  // 向下传递事件
  deletaTack = (index) => {。。。。}

  // 一级组件
  render() {
    return (
      <>
        //  向下传递数据 和 函数
        <List list={this.state.list} deletaTack={this.deletaTack} />
      </>
    )
  }
  ```

  ```js
  // 二级组件
  render() {
    const {list, deletaTack} = this.props;
    return (
      <ul>
        {
          // 向下传递 数据 和 函数
          list.map((item, index) =>
            return (<Conten index={index} key={item + index} task={item} deletaTack={deletaTack} />
            )
          )
        }
      </ul>
    )
  }
  ```

  ```js
  <!-- 三级组件 -->
  render() {
    const {task, index} = this.props;
    return (
      <li>
        {task}
        {/* 不用传递传输 */}
        {/* <button onClick={this.deleteValue}>删除</button> */}
        {/* 传递参数 */}
        <button onClick={() => {this.deleteValue(index)}}>删除</button>
      </li>
    )
  }

  deleteValue = (index) => {
    this.props.deletaTack(index);
  }
  ```

## 示例：遮罩层

+ 父组件

  ```jsx
  export default class App extends Component {
    constructor(props) {
      super(props);
      this.state = {
        isBool: false
      }
    }

    render() {
      const { isBool } = this.state;

      return (
        <div className="App">

          <button onClick={ this.setShowFunc.bind(this, true) }>点击打开遮罩层</button>
            {
              isBool ?
                (
                  // 当子组件点击 最外层时,给父元素抛出一个 onClickShow 事件,供父元素处理
                  <Modal onClickShow={ this.setShowFunc.bind(this, false) }>
                    <button onClick={ this.setShowFunc.bind(this, false) }>关闭遮罩层</button>
                  </Modal>
                )
              : null
            }
        </div>
      )
    }

    // 显示/关闭
    setShowFunc = (isBool) => {
      this.setState( () => {
        return {
          isBool
        }
      })
    }
  }
  ```

+ 子组件

  ```jsx
  export default function Modal(props) {

    const stopMp = (e) => {
      // 阻止冒泡
      e.stopPropagation();
    }

    return (
      <div className="modal" onClick={ props.onClickShow }>
        Modal
        <div className="box" onClick={ stopMp }>
          { props.children }
        </div>
      </div>
    )
  }
  ```

## 跨组件传递

+ `Provider` 和 `Consumer`  **16版本**之后添加的

+ `Provider` 是 提供者，也就是 上级组件使用

+ `Consumer` 是 消费者, 也就是 使用者

  ```js
  // 注册组件 context.js
  import React from 'react';

  const {Provider, Consumer} = React.createContext();

  export {
    Provider,
    Consumer
  }
  ```

  ```js
  // 上级组件
  // 导入 Provider
  import React from 'react';
  import {Provider} from './context'

  deletaTack = (index) => {
    // console.log(idnex);
    const list = [...this.state.list];
    list.splice(index, 1);
    this.setState({
      list
    })
  }

  render() {
    return (
      <!-- 传递 -->
      <Provider value={{deletaTack: this.deletaTack}}>
        <div>
          <input type="text" ref={this.valueB} />
          <button onClick={this.clickList}>添加</button>
        </div>
        <List list={this.state.list} />
      </Provider>
    )
  }
  ```

+ Consumer 使用起来注意格式。标签内是一个函数。必须为根组件

  ```js
  <Consumer>
    {
      ({接受的值}) => {

      }
    }
  </Consumer>
  ```

+ 子组件

  ```js
  // 使用
  import {Consumer} from './context';

  render() {
    return (
      <Consumer>
        {
          ({hendlDelete}) =>
            // return (
              <ul>
                List.js 组件
                {
                  list.map((itme, index) => {
                    return (
                      <li key={itme.name + index}>
                        <p>{ itme.name } + { index }</p>
                        <button onClick={ hendlDelete.bind(index)}>删除</button>
                      </li>
                    )
                  })
                }
              </ul>
            // )
          // }
        }
      </Consumer>
    )
  }
  ```
