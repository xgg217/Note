# 按需加载

## 作用

+ 将代码拆分为各种捆绑包，然后按需加载或并行加载的技术

## Suspense

+ 如果在 ·`MyComponent` 渲染完成后，包含 `OtherComponent` 的模块还没有被加载完成，我们可以使用加载指示器为此组件做优雅降级

+ 这里我们使用 `Suspense` 组件来解决

## React.lazy 常规使用

+ 代码

  ```js
  const OtherComponent = React.lazy(() => import('./OtherComponent'));

  function MyComponent() {
    return (
      <div>
        <Suspense fallback={<div>Loading...</div>}>
          <OtherComponent />
        </Suspense>
      </div>
    );
  }
  ```

+ 你可以将 `Suspense` 组件置于懒加载组件之上的任何位置。你甚至可以用一个 `Suspense` 组件包裹多个懒加载组件

  ```js
  const OtherComponent = React.lazy(() => import('./OtherComponent'));
  const AnotherComponent = React.lazy(() => import('./AnotherComponent'));

  function MyComponent() {
    return (
      <div>
        <Suspense fallback={<div>Loading...</div>}>
          <section>
            <OtherComponent />
            <AnotherComponent />
          </section>
        </Suspense>
      </div>
    );
  }
  ```

## React.lazy 和 React-Router 配合

+ `React.lazy` 目前只支持默认导出（`default exports`）

+ 如果你想被引入的模块使用命名导出（named exports），你可以创建一个中间模块，来重新导出为默认模块

+ 这能保证 tree shaking 不会出错，并且不必引入不需要的组件

  ```js
  // ManyComponents.js
  export const MyComponent = /* ... */;
  export const MyUnusedComponent = /* ... */;
  ```

  ```js
  // MyComponent.js
  export { MyComponent as default } from "./ManyComponents.js";
  ```

  ```js
  // MyApp.js
  import React, { lazy } from 'react';
  const MyComponent = lazy(() => import("./MyComponent.js"));
  ```

+ `React.lazy` 和 `React-Router` 配合使用代码

  ```js
  import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
  import React, { Suspense, lazy } from 'react';

  const Home = lazy(() => import('./routes/Home'));
  const About = lazy(() => import('./routes/About'));

  const App = () => (
    <Router>
      <Suspense fallback={<div>加载中...</div>}>
        <Switch>
          <Route exact path="/" component={Home}/>
          <Route path="/about" component={About}/>
        </Switch>
      </Suspense>
    </Router>
  );
  ```
