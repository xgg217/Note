# 基础

## 作用

+ `bind()` 方法创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用

  ```js
  const module = {
    x: 42,
    getX: function() {
      return this.x;
    }
  };

  const unboundGetX = module.getX;
  console.log(unboundGetX()); // The function gets invoked at the global scope
  // expected output: undefined

  const boundGetX = unboundGetX.bind(module);
  console.log(boundGetX());
  // expected output: 42
  ```

## 注意点

+ 每次返回一个新函数

+ 结合回调函数使用

## 语法

+ `function.bind(thisArg[, arg1[, arg2[, ...]]])`

+ 返回值：返回一个原函数的拷贝，并拥有指定的 `this` 值和初始参数

## 每次返回一个新函数

+ `click` 事件绑定 `bind` 方法生成的一个匿名函数。这样会导致无法取消绑定

  ```js
  // 错误写法
  element.addEventListener('click', o.m.bind(o));

  // 无法取消时间，此代码无效
  element.removeEventListener('click', o.m.bind(o));
  ```

  ```js
  // 正确写法
  var listener = o.m.bind(o);
  element.addEventListener('click', listener);
  //  ...
  element.removeEventListener('click', listener);
  ```

## 结合回调函数使用

+ 回调函数是JavaScript最常用的模式之一，但是一个常见的错误是，将包含 `this` 的方法直接当作回调函数

  ```js
  var counter = {
    count: 0,
    inc: function () {
      'use strict';
      this.count++;
    }
  };

  function callIt(callback) {
    callback();
  }

  callIt(counter.inc)
  // TypeError: Cannot read property 'count' of undefined
  ```

+ 解决办法：使用 `bind`

  ```js
  callIt(counter.inc.bind(counter));
  counter.count // 1
  ```
