# 基础

## 利用空对象作为中介

+ 修改Cat的prototype对象，就不会影响到Animal的prototype对象

  ```js
  function extend(Child, Parent) {
    var F = function(){};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
    Child.uber = Parent.prototype; // 为子对象设一个uber属性，这个属性直接指向父对象的prototype属性
  }
  ```

  ```js
  function Animal(){
    this.species = "动物";
  }
  function Cat(name,color){
    this.name = name;
    this.color = color;
  }
  extend(Cat,Animal);
  var cat1 = new Cat("大毛","黄色");
  alert(cat1.species); // 动物
  ```

## 拷贝继承

+ 如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承

## 圣杯模式

+ 圣杯模式

  ```js
  /**js继承(圣杯模式)
  * Target继承Origin
  * @param {*} Target
  * @param {*} Origin 被继承
  */
  var inherit = (function (){
    var F = function () {};
    return function(Target, Origin) {
        F.prototype = Origin.prototype;
        Target.prototype = new F();
        Target.prototype.constructor = Target;
        Target.prototype.uber = Origin.prototype; // 标记继承自谁
    }
  }());
  ```
