# 依赖预构建

## 概述

+ 一句话总结：在你**首次**使用 Vite 启动项目的时候，会把你的项目**依赖**预先构建一次

+ 思考🤔：前面不是说 Vite 相比 Webpack 的优点不就是不打包么？这里预构建又是怎么一回事儿？

## 存在的问题：

1. 依赖文件过多，导致请求过多
2. 某些依赖仍然是以 CommonJS 格式发布的，它们并不兼容原生 ESM 环境

## 解决

+ 为了解决上面的两个问题，Vite在第一次启动项目的时候，会针对 **依赖** 进行一个预构建（打包）

+ 预构建阶段所使用的打包工具是 [esbuild](https://esbuild.github.io/)，这是一个用 Go 语言编写的构建工具，效率极高，**大部分工作都是并行处理的**，esbuild 能够迅速将依赖转换为有效的 ES 模块格式，并进行打包，从而优化依赖管理和加载效率

+ esbuild 所做的事情：

  1. 转换：将一些 CommonJS、UMD 格式的模块转换为 ES 模块格式
  2. 打包：针对依赖进行打包，减少浏览器在开发环境请求的次数
  3. 最小化和压缩：这个是在构建阶段，针对代码的最小化和压缩也是 esbuild 来做的

## 缓存

+ 缓存分为两种：

  1. 文件缓存
  2. 浏览器缓存

+ 针对依赖项做构建后，会将构建产物做缓存，缓存到 node_modules/.vite 目录下面

+ 什么时候需要重新运行预构建步骤：

  + 包管理器的锁文件内容，例如 package-lock.json，yarn.lock，pnpm-lock.yaml，或者 bun.lockb 发生了变化
  + 补丁文件夹的修改时间发生了变化
  + vite.config.js 中的相关字段发生了变化，在配置文件中也存在依赖预构建的相关配置，依赖预构建相关配置发生了变化，自然需要重新预构建
  + NODE_ENV 的值变动

+ 上述任意一项发生更改时，需要重新运行预构建

+ 另外，已预构建的依赖，**在浏览器端也会存在缓存**
+ 会使用 HTTP 头 max-age=31536000, immutable 进行**强缓存**，以提高开发期间页面重新加载的性能
+ 一旦被缓存，这些请求将永远不会再次访问开发服务器

+ 如果安装了不同版本的依赖项（这反映在包管理器的 lockfile 中），则会通过附加版本查询把之前的强缓存自动失效

+ 例如：当前项目使用了 lodash，当前版本为 4.17.19

  ```
  http://localhost:3000/node_modules/.vite/lodash.js?v=4.17.19
  ```

+ 之后对 lodash 版本升级，升级到 4.17.20，锁文件内容变化会导致重新预构建

  ```
  http://localhost:3000/node_modules/.vite/lodash.js?v=4.17.20
  ```

+ URL发生变化后，浏览器就会发生新的请求到开发服务器，而不再使用旧的缓存

## 自定义预构建行为

+ 在配置文件中，通过 optimizeDeps 对预构建行为进行配置
+ 一个基本的格式：

  ```js
  // vite.config.js
  import { defineConfig } from 'vite';

  export default defineConfig({
    optimizeDeps: {
      // 其他的配置
    }
  });
  ```

