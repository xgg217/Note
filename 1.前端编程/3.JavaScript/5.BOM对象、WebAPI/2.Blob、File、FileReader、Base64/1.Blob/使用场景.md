# 使用场景

## 图片本地预览

1. 使用 DataURL

    ```html
     <h1>1.DataURL方式：</h1>
    <input type="file" accept="image/*" onchange="selectFileForDataURL(event)">
    <img id="output1">
    ```

    ```js
    // 1.DataURL方式：
    async function selectFileForDataURL() {
        const reader = new FileReader();
        reader.onload = function () {
            const output = document.querySelector("#output1")
            output.src = reader.result;
        }
        reader.readAsDataURL(event.target.files[0]);
    }
    ```

2. 使用 Blob URL/Object URL

    ```html
    <h1>2.Blob方式：</h1>
    <input type="file" accept="image/*" onchange="selectFileForBlob(event)">
    <img id="output2">
    ```

    ```js
    //2.Blob方式：
    async function selectFileForBlob(){
        const reader = new FileReader();
        const output = document.querySelector("#output2");
        const imgUrl = window.URL.createObjectURL(event.target.files[0]);
        output.src = imgUrl;
        reader.onload = function(event){
            window.URL.revokeObjectURL(imgUrl);
        }
    }
    ```

## 本地预览 + 分片上传

+ 实现本地预览

    1. 将 `input` 获取到的 `file` 对象，通过实例化 `fileReader`，赋值给变量 `reader`，调用 `reader` 的 `readAsDataURL` 方法，将 `file` 对象转换为 `dataURL`

    2. 然后监听 `reader` 的 `onload` 属性，获取读取结果 `result`

    3. 设置图片的 `src`

+ 实现分片上传

  + 由于 File 是特殊类型的 Blob，可用于任意 Blob 类型的上下文，所以针对大文件传输，我们可以使用 slice 方法进行文件切割 分片上传

  ```html
  <input type="file" accept="image/*" onchange="selectFile(event)">
  <button onclick="upload()">上传</button>
  <img id="output">
  ```

  ```js
  const chunkSize = 10000;
  const url = "https://httpbin.org/post";
  async function selectFile(){
  // 本地预览
    const reader = new FileReader();
    reader.onload = function(){
      const output = document.querySelector("#output")
      output.src = reader.result;
    }
    reader.readAsDataURL(event.target.files[0]);

    // 分片上传
    await upload(event.target.files[0]);
  }
  async function upload(files){
    const file = files;
    for(let start = 0; start < file.size; start += chunkSize){
      const chunk = file.slice(start, start + chunkSize + 1);
      const fd = new FormData();
      fd.append("data", chunk);
      await fetch(url, { method: "post", body: fd }).then((res) =>{
        console.log(res)
        res.text();
      });
    }
  }
  ```

## 图片本地预览+ 分片上传 + 暂停 + 续传

+ 代码

  ```html
  <input type="file" accept="image/*" onchange="selectFile(event)">
  <button onclick="upload()">上传</button>
  <button onclick="pause()">暂停</button>
  <button onclick="continues()">继续</button>
  <img id="output" src="" alt="">
  ```

  ```js
  const chunkSize = 30000;
  let start = 0, curFile, isPause = false;
  const url = "https://httpbin.org/post";
  async function selectFile(){
    const reader = new FileReader();
    reader.onload = function(){
      const output = document.querySelector("#output")
      output.src = reader.result;
    }
    reader.readAsDataURL(event.target.files[0]);
    curFile = event.target.files[0];
  }
  async function upload(){
    const file = curFile;
    for(start; start < file.size; start += chunkSize){
      if(isPause) return;
      const chunk = file.slice(start, start + chunkSize + 1);
      const fd = new FormData();
      fd.append("data", chunk);
      await fetch(url, { method: "post", body: fd }).then((res) =>{
            res.text()
        }
      );
      if(chunk.size < chunkSize){
        uploadSuccess();
        return;
      }
    }
  }
  function pause(){
    isPause = true;
  }
  function continues(){
    isPause = false;
    upload();
  }
  function uploadSuccess(){
    isPause = false;
    start = 0;
  }
  ```

## 从互联网下载数据

+ 在实现“从互联网下载数据”方法时，我们使用 `createObjectURL`  显示图片，在请求互联网图片时，我们有两种方式：

    1. XMLHttpRequest

    2. fetch

  ```js
  // XMLHttpRequest 下载
  const url = "http://images.pingan8787.com/TinyCompiler/111.png";
  const pingan = document.querySelector('#pingan');
  function download1 (){
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.responseType = 'blob';
    xhr.onload = () => {
      renderImage(xhr.response);
    }
    xhr.send(null);
  }
  ```

  ```js
  const url = "http://images.pingan8787.com/TinyCompiler/111.png";
  const pingan = document.querySelector('#pingan');

  function download2 (){
    fetch(url).then(res => {
      return res.blob();
    }).then(myBlob => {
      renderImage(myBlob);
    })
  }

  function renderImage (data){
    let objectURL = URL.createObjectURL(data);
    pingan.src = objectURL;
  // 根据业务需要手动调用 URL.revokeObjectURL(imgUrl)
  }

  ```

## 下载文件

+ 通过调用 Blob 的构造函数来创建类型为 `"text/plain"`  的 Blob 对象，然后通过动态创建 `a`  标签来实现文件的下载

  ```js
  // Blob 文件下载
  function download(){
    const fileName= "Blob文件.txt";
    const myBlob = new Blob(["一文彻底掌握 Blob Web API"], { type: "text/plain" });
    downloadFun(fileName, myBlob);
  }
  function downloadFun(fileName, blob){
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = fileName;
    link.click();
    link.remove();
    URL.revokeObjectURL(link.href);
  }
  ```

## 图片压缩

+ 当我们希望本地图片在上传之前，先进行一定压缩，再提交，从而减少传输的数据量

+ 在前端我们可以使用 Canvas 提供的 `toDataURL()`  方法来实现，该方法接收 `type` 和 `encoderOptions`  两个可选参数：

  + type  表示 「图片格式」，默认为 `image/png`

  + encoderOptions  表示 「图片质量」，在指定图片格式为 `image/jpeg` 或 `image/webp`  的情况下，可以从 0 到 1 区间内选择图片质量。如果超出取值范围，将会使用默认值  `0.92` ，其他参数会被忽略

    ```html
    <input type="file" accept="image/*" onchange="loadFile(event)" />
    ```

    ```js
    // compress.js
    const MAX_WIDTH = 800; // 图片最大宽度
    // 图片压缩方法
    function compress(base64, quality, mimeType) {
      let canvas = document.createElement("canvas");
      let img = document.createElement("img");
      img.crossOrigin = "anonymous";
      return new Promise((resolve, reject) => {
        img.src = base64;
        img.onload = () => {
          let targetWidth, targetHeight;
          if (img.width > MAX_WIDTH) {
            targetWidth = MAX_WIDTH;
            targetHeight = (img.height * MAX_WIDTH) / img.width;
          } else {
            targetWidth = img.width;
            targetHeight = img.height;
          }
          canvas.width = targetWidth;
          canvas.height = targetHeight;
          let ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, targetWidth, targetHeight); // 清除画布
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          let imageData = canvas.toDataURL(mimeType, quality / 100); // 设置图片质量
          resolve(imageData);
        };
      });
    }

    // 为了进一步减少传输的数据量，我们可以把它转换为 Blob 对象
    function dataUrlToBlob(base64, mimeType) {
      let bytes = window.atob(base64.split(",")[1]);
      let ab = new ArrayBuffer(bytes.length);
      let ia = new Uint8Array(ab);
      for (let i = 0; i < bytes.length; i++) {
        ia[i] = bytes.charCodeAt(i);
      }
      return new Blob([ab], { type: mimeType });
    }

    // 通过 AJAX 提交到服务器
    function uploadFile(url, blob) {
      let formData = new FormData();
      let request = new XMLHttpRequest();
      formData.append("image", blob);
      request.open("POST", url, true);
      request.send(formData);
    }

    function loadFile(event) {
      const reader = new FileReader();
      reader.onload = async function () {
      let compressedDataURL = await compress(
          reader.result,
          90,
          "image/jpeg"
        );
        let compressedImageBlob = dataUrlToBlob(compressedDataURL);
        uploadFile("https://httpbin.org/post", compressedImageBlob);
      };
      reader.readAsDataURL(event.target.files[0]);
    };
    ```

+ 其实 Canvas 对象除了提供 `toDataURL()` 方法之外，他还提供了 `toBlob()` 方法，该方法的语法如下

  ```js
  canvas.toBlob(callback, mimeType, qualityArgument)
  ```

+ 和 `toDataURL()` 方法相比，`toBlob()` 方法是异步的，因此多了个 `callback` 参数，这个 `callback` 回调方法默认的第一个参数就是转换好的 `blob` 文件信息

## 生成PDF

+ 在浏览器端，利用现成开源库 jsPDF 我们也可以方便的生成 PDF 文档

  ```html
  <body>
    <h3>客户端生成 PDF 示例</h3>
    <script src="https://unpkg.com/jspdf@latest/dist/jspdf.min.js"></script>
    <script>
      (function generatePdf() {
        const doc = new jsPDF();
        doc.text("Hello semlinker!", 66, 88);
        const blob = new Blob([doc.output()], { type: "application/pdf" });
        blob.text().then((blobAsText) => {
          console.log(blobAsText);
        });
      })();
    </script>
  </body>
  ```

+ 其实 jsPDF 除了支持纯文本之外，它也可以生成带图片的 PDF 文档，比如：

  ```js
  let imgData = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/...'
  let doc = new jsPDF();

  doc.setFontSize(40);
  doc.text(35, 25, 'Paranyan loves jsPDF');
  doc.addImage(imgData, 'JPEG', 15, 40, 180, 160);
  ```
