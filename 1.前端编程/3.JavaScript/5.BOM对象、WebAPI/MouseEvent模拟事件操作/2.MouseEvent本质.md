# MouseEvent 本质

## 事件流程

+ 前端代码

  ```js
  button.addEventListener('click', function(event) {
    console.log(event.clientX, event.clientY); 
  });
  ```

+ 背后的完整流程

  ```js
  // 1. 浏览器接收硬件点击信号

  // 2. 自动构建MouseEvent实例
  const syntheticEvent = new MouseEvent('click', {
    clientX: 精确计算的横坐标,
    clientY: 精准定位的纵坐标,
    button: 0,        // 智能识别鼠标按键
    bubbles: true,    // 启用事件冒泡机制
    isTrusted: true   // 标记为系统原生事件
  });

  // 3. 隐式执行dispatchEvent启动事件流
  button.dispatchEvent(syntheticEvent);
  ```

## 本质

+ 这是浏览器内置的事件构造器，通过new操作符生成事件对象（即回调函数中的event参数） 属于Web事件体系中的核心成员：

  ```
  Event (基础类)
  ├── UIEvent
  │   ├── FocusEvent    // 聚焦相关事件
  │   ├── MouseEvent    // 鼠标交互事件 ← 点击事件归属！
  │   └── KeyboardEvent // 键盘输入事件
  ├── InputEvent        // 表单输入事件
  └── CustomEvent       // 开发者自定义事件
  ```

## dispatchEvent的作用

+ 关键认知：addEventListener实际监听的是dispatchEvent的调用，而非直接响应硬件操作！
+ 浏览器在物理交互发生时，自动完成：构建事件对象 + 执行dispatchEvent 所谓的"用户交互"本质上是这两个环节的组合

## 事件传播的完整路径

+ 事件传播的完整路径:这正是点击内部元素时，外层监听器也会响应的原因——事件会沿着DOM结构向上传递！

  ```
  物理交互发生
    ↓
  浏览器解析硬件信号
      ↓  
  浏览器构建对应Event实例
      ↓
  浏览器隐式执行element.dispatchEvent(event) ← 事件流的起点！
      ↓
  进入捕获阶段 (document → target)
      ↓ 执行所有捕获阶段监听器
  到达目标阶段 (target)
      ↓ 执行目标元素绑定处理器
  进入冒泡阶段 (target → document)  
      ↓ 执行所有冒泡阶段监听器
      ↓
  事件生命周期完结
  ```
