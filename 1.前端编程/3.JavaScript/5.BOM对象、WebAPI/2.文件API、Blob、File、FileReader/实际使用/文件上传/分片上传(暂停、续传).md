# 分片上传

## 概述

+ 分片上传 (Chunked Upload) 是将文件分成若干个小块（通常是几MB大小），然后将每一块单独上传
+ 这样，当网络状态较差时，只会有一小部分的数据受到影响，而不是整个文件上传失败。分片上传还可以让服务器端并行处理多个分片，提高上传速度

+ 实现分片上传

  + 由于 File 是特殊类型的 Blob，可用于任意 Blob 类型的上下文，所以针对大文件传输，我们可以使用 slice 方法进行文件切割 分片上传

## 示例

+ 简易版

  ```js
  // 需要上传的文件
  const fileObj = e.target.files[0]

  // 上传
  async submit() {
    // 切片上传
    const size = 2 *1024 * 1024; // 切片大小
    const fileSize = fileObj.size; // 当前文件大小
    let current = 0;
    while(current < fileSize) {
      let newCurrent = current + size;
      const formData = new FormData();
      formData.append("file",fileObj.slice(current, newCurrent));
      await axios.post("http://localhose:4000/upload", formData)
      current = newCurrent
    }
  }
  ```

+ 代码

  ```js
  const oProgress = document.querySelector('progress');
  const oFile = document.querySelector('input[type="file"]');
  const oInfo = document.querySelector('.info');
  const oBtn = document.querySelector('button');

  let uploadSize = 0; // 已经上传的大小

  const uploadVideo = async () => {
    console.log('文件');
    console.log(oFile.files[0]);
    const file = oFile.files[0];

    if(!file) {
      alert('请选择文件');
      oInfo.innerText = UPLOAD_INFO.NO_FILE;
      return;
    }

    if(!ALLOW_FILE_TYPE.includes(file.type)) {
      alert('文件类型不正确');
      oInfo.innerText = UPLOAD_INFO.INVALID_TYPE;
      return;
    }

    oInfo.innerHTML = UPLOAD_INFO.LOADING;

    const { name, type, size } = file
    let uploaderReault = null;
    const fileName = Date.now() + '_' + name;
    oProgress.max = size;

    const createFormData =  (
      {
        name,
        type,
        size,
        fileName,
        uploadSize,
        file
      }
    ) => {
      const fd = new FormData();
      fd.append('name', name);
      fd.append('type', type);
      fd.append('size', size);
      fd.append('fileName', fileName);
      fd.append('uploadSize', uploadSize);
      fd.append('file', file);

      return fd;
    }

    // 切割文件 + 上传
    while(uploadSize < size) {
      const fileChunk = file.slice(uploadSize, uploadSize + CHUNK_SIZE);
      const formData = createFormData({ name, type, size, fileName, uploadSize, file: fileChunk });

      try {
        uploaderReault = await axios.post(API.UPLOAD_VIDEO, formData)
      } catch (e) {
        console.error(e);
        oInfo.innerHTML = UPLOAD_INFO.ERROR + e.msg;
        return
      }

      uploadSize += fileChunk.size;
      oProgress.value = uploadSize;
    }
    console.log('上传成功');

    oInfo.innerHTML = UPLOAD_INFO.SUCCESS;
    oFile.value = null;
  }

  // 事件
  const bindEvent = () => {
    oBtn.addEventListener('click', uploadVideo)
  }

  const init = () => {
    bindEvent()
  };

  init();
  ```

## 本地预览 + 分片上传

+ 实现本地预览

    1. 将 `input` 获取到的 `file` 对象，通过实例化 `fileReader`，赋值给变量 `reader`，调用 `reader` 的 `readAsDataURL` 方法，将 `file` 对象转换为 `dataURL`

    2. 然后监听 `reader` 的 `onload` 属性，获取读取结果 `result`

    3. 设置图片的 `src`

+ 实现分片上传

  + 由于 File 是特殊类型的 Blob，可用于任意 Blob 类型的上下文，所以针对大文件传输，我们可以使用 slice 方法进行文件切割 分片上传

  ```html
  <input type="file" accept="image/*" onchange="selectFile(event)">
  <button onclick="upload()">上传</button>
  <img id="output">
  ```

  ```js
  const chunkSize = 10000;
  const url = "https://httpbin.org/post";
  async function selectFile(){
    // 本地预览
    const reader = new FileReader();
    reader.onload = function(){
      const output = document.querySelector("#output")
      output.src = reader.result;
    }
    reader.readAsDataURL(event.target.files[0]);

    // 分片上传
    await upload(event.target.files[0]);
  }
  async function upload(files){
    const file = files;
    for(let start = 0; start < file.size; start += chunkSize){
      const chunk = file.slice(start, start + chunkSize + 1);
      const fd = new FormData();
      fd.append("data", chunk);
      await fetch(url, { method: "post", body: fd }).then((res) =>{
        console.log(res)
        res.text();
      });
    }
  }
  ```

## 图片本地预览+ 分片上传 + 暂停 + 续传

+ 代码

  ```html
  <input type="file" accept="image/*" onchange="selectFile(event)">
  <button onclick="upload()">上传</button>
  <button onclick="pause()">暂停</button>
  <button onclick="continues()">继续</button>
  <img id="output" src="" alt="">
  ```

  ```js
  const chunkSize = 30000;
  let start = 0, curFile, isPause = false;
  const url = "https://httpbin.org/post";
  async function selectFile(){
    const reader = new FileReader();
    reader.onload = function(){
      const output = document.querySelector("#output")
      output.src = reader.result;
    }
    reader.readAsDataURL(event.target.files[0]);
    curFile = event.target.files[0];
  }
  async function upload(){
    const file = curFile;
    for(start; start < file.size; start += chunkSize){
      if(isPause) return;
      const chunk = file.slice(start, start + chunkSize + 1);
      const fd = new FormData();
      fd.append("data", chunk);
      await fetch(url, { method: "post", body: fd }).then((res) =>{
            res.text()
        }
      );
      if(chunk.size < chunkSize){
        uploadSuccess();
        return;
      }
    }
  }
  function pause(){
    isPause = true;
  }
  function continues(){
    isPause = false;
    upload();
  }
  function uploadSuccess(){
    isPause = false;
    start = 0;
  }
  ```

