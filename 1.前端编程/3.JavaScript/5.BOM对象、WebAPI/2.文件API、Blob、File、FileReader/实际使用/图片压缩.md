# 图片压缩

## 概述

+ 当我们希望本地图片在上传之前，先进行一定压缩，再提交，从而减少传输的数据量

+ 在前端我们可以使用 Canvas 提供的 `toDataURL()`  方法来实现，该方法接收 `type` 和 `encoderOptions`  两个可选参数：

  + type  表示 「图片格式」，默认为 `image/png`

  + encoderOptions  表示 「图片质量」，在指定图片格式为 `image/jpeg` 或 `image/webp`  的情况下，可以从 0 到 1 区间内选择图片质量。如果超出取值范围，将会使用默认值  `0.92` ，其他参数会被忽略

    ```html
    <input type="file" accept="image/*" onchange="loadFile(event)" />
    ```

    ```js
    // compress.js
    const MAX_WIDTH = 800; // 图片最大宽度
    // 图片压缩方法
    function compress(base64, quality, mimeType) {
      let canvas = document.createElement("canvas");
      let img = document.createElement("img");
      img.crossOrigin = "anonymous";
      return new Promise((resolve, reject) => {
        img.src = base64;
        img.onload = () => {
          let targetWidth, targetHeight;
          if (img.width > MAX_WIDTH) {
            targetWidth = MAX_WIDTH;
            targetHeight = (img.height * MAX_WIDTH) / img.width;
          } else {
            targetWidth = img.width;
            targetHeight = img.height;
          }
          canvas.width = targetWidth;
          canvas.height = targetHeight;
          let ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, targetWidth, targetHeight); // 清除画布
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          let imageData = canvas.toDataURL(mimeType, quality / 100); // 设置图片质量
          resolve(imageData);
        };
      });
    }

    // 为了进一步减少传输的数据量，我们可以把它转换为 Blob 对象
    function dataUrlToBlob(base64, mimeType) {
      let bytes = window.atob(base64.split(",")[1]);
      let ab = new ArrayBuffer(bytes.length);
      let ia = new Uint8Array(ab);
      for (let i = 0; i < bytes.length; i++) {
        ia[i] = bytes.charCodeAt(i);
      }
      return new Blob([ab], { type: mimeType });
    }

    // 通过 AJAX 提交到服务器
    function uploadFile(url, blob) {
      let formData = new FormData();
      let request = new XMLHttpRequest();
      formData.append("image", blob);
      request.open("POST", url, true);
      request.send(formData);
    }

    function loadFile(event) {
      const reader = new FileReader();
      reader.onload = async function () {
      let compressedDataURL = await compress(
          reader.result,
          90,
          "image/jpeg"
        );
        let compressedImageBlob = dataUrlToBlob(compressedDataURL);
        uploadFile("https://httpbin.org/post", compressedImageBlob);
      };
      reader.readAsDataURL(event.target.files[0]);
    };
    ```

+ 其实 Canvas 对象除了提供 `toDataURL()` 方法之外，他还提供了 `toBlob()` 方法，该方法的语法如下

  ```js
  canvas.toBlob(callback, mimeType, qualityArgument)
  ```

+ 和 `toDataURL()` 方法相比，`toBlob()` 方法是异步的，因此多了个 `callback` 参数，这个 `callback` 回调方法默认的第一个参数就是转换好的 `blob` 文件信息
