# 语法

## API

+ API

  ```js
  fetch(resource)
  fetch(resource, options)
  ```

+ 参数

  + resource  定义你想要获取的资源。可以是：

    + 一个字符串或任何其他具有字符串化器的对象（包括 URL 对象），提供你想要获取的资源的 URL。URL 可以是相对于基础 URL 的，基础 URL 是窗口上下文中文档的 baseURI 或者 worker 上下文中的 WorkerGlobalScope.location
    + 一个 Request 对象

  + options 可选 一个包含你想要应用到请求上的任何自定义设置的 RequestInit 对象。

+ 返回值 一个 Promise，会兑现 Response 对象

  + 当网络发生错误（获取其他导致无法完成交换的错误，也就是请求没有到服务器中），`Promise` 进入 `rejected` 状态，状态数据为错误信息
  + fetch() 的 promise 不会因为服务器响应表示错误的 HTTP 状态码（404、504，等）而被拒绝。因此，then() 处理器必须检查 Response.ok 和/或 Response.status 属性

+ 异常

  + `AbortError DOMException` 请求被 AbortController 的 abort() 方法调用所终止

  + `NotAllowedError DOMException`  如果 Topics API 的使用被 browsing-topics 权限策略明确禁止，且 fetch() 请求中包含 browsingTopics: true，则会抛出此异常

  + TypeError

  ```js
  async function postData(url = "", data = {}) {
    // Default options are marked with *
    const response = await fetch(url, {
      method: "POST", // *GET, POST, PUT, DELETE, etc.
      mode: "cors", // no-cors, *cors, same-origin
      cache: "no-cache", // *default, no-cache, reload, force-cache, only-if-cached
      credentials: "same-origin", // include, *same-origin, omit
      headers: {
        "Content-Type": "application/json",
        // 'Content-Type': 'application/x-www-form-urlencoded',
      },
      redirect: "follow", // manual, *follow, error
      referrerPolicy: "no-referrer", // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
      body: JSON.stringify(data), // body data type must match "Content-Type" header
    });
    return response.json(); // parses JSON response into native JavaScript objects
  }

  postData("https://example.com/answer", { answer: 42 }).then((data) => {
    console.log(data); // JSON data parsed by `data.json()` call
  });
  ```

### 参数2 options 配置对象

+ `method`: 字符串，请求使用的方法，如 `GET`、`POST`。默认 `GET`

+ `headers`: 对象，请求的头信息

+ `body`: 请求的内容，必须匹配请求头中的 `Content-Type`

  + 不管是请求还是响应都能够包含 body 对象。body 也可以是以下任意类型的实例。

    + ArrayBuffer
    + ArrayBufferView (Uint8Array 等)
    + Blob/File
    + string
    + URLSearchParams
    + FormData

  + Body 类定义了以下方法（这些方法都被 Request 和 Response所实现）以获取 body 内容。这些方法都会返回一个被解析后的 Promise 对象和数据

    + `Request.arrayBuffer()` / `Response.arrayBuffer()`
    + `Request.blob()` / `Response.blob()`
    + `Request.formData()` / `Response.formData()`
    + `Request.json()` / `Response.json()`
    + `Request.text()` / `Response.text()`

  + 参考 https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch#body

  ```js
  const form = new FormData(document.getElementById("login-form"));
  fetch("/login", {
    method: "POST",
    body: form,
  })
  ```

+ `mode`: 字符串，请求的模式。主要解决跨越问题

  + `cors`：默认值，配置为该值，会在请求头中加入 `origin` 和 `referer`

  + `no-cors`：配置为该值，不会在请求头中加入 `origin` 和 `referer`，跨域的时候可能会出现问题

  + `same-origin`：指示请求必须在同一个域中发生，如果请求其他域，则会报错

+ `credentials`: 如果携带凭证(`cookie`)

  + `omit`：默认值，不携带 `cookie`

  + `same-origin`：请求同源地址时携带 `cookie`

  + `include`：请求任何地址都携带 `cookie`

+ cache: 配置缓存模式

  + `default`：表示 fetch 请求之前将检查下 http 的缓存

  + `no-store`：

  + `reload`：

  + `no-cache`：

  + `force-cache`：

  + `only-if-cached`：

  ```js
  function postData(url, data) {
    return fetch(url, {
      body: JSON.stringify(data),
      cache: 'no-cache',
      credentials: 'same-origin',
      headers: {
        'content-type': 'application/json'
      },
      method: 'POST',
      mode: 'cors',
      redirect: 'follow',
      referrer: 'no-referrer',
    })
    .then(response => response.json()) // parses response to JSON
  }
  ```

+ `keepalive` 如果设置为 `trur` 即便页面被终止请求也会保持连接

  + 如果想在页面跳转的时候发送请求推荐使用 `Navigator.sendBeacon()`

### 返回值 Response 对象

+ `ok`：`Boolean`，当相应消息码在 200\~299 之间时为 `true`，其他为 `false`

+ status：`Number`，相应的状态码

+ `test()`：用于处理文本格式的 Ajax 响应。它从响应中获取文本流，将其读完，然后返回一个被解决为 `string` 对象的 `Promise`

+ `blob()`：用于处理二进制文件格式（比如图片或者电子表格）的Ajax 相应。他读取文件的原始数据，一旦读取完 整个问价，就返回一个被解决为 `blob` 对象的 `Promise`

+ `json()`：用于处理 `JSON` 格式的 `Ajax` 的响应。它将 JSON 数据流转换为一个被解决为 `JavaScript` 对象的 `Promise`

+ `redirect()`：用于重定向到另外一个 URL。他会创建一个新的 `Promise`，以解决来自重定向的 URL 的响应
