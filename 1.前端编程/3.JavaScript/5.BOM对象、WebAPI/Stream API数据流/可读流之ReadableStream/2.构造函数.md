# 构造函数 ReadableStream.ReadableStream()

## 概述

+ ReadableStream() 构造函数创建并从给定的处理程序返回一个可读的流对象

## 语法

+ API

  ```js
  new ReadableStream()
  new ReadableStream(underlyingSource)
  new ReadableStream(underlyingSource, queuingStrategy)
  ```

+ 参数

  + underlyingSource 可选 一个包含定义了构造流行为方法和属性的对象。underlyingSource 包括：

    + start (controller) 可选

      + 这是一个当对象被构造时立刻调用的方法。此方法的内容由开发人员定义，并应着眼于访问流，并执行其他任何必需的设置流功能。如果这个过程是异步完成的，它可以返回一个 promise，表明成功或失败
      + 传递给这个方法的 controller 是一个 ReadableStreamDefaultController 或 ReadableByteStreamController，具体取决于 type 属性的值
      + 开发人员可以使用此方法在设立期间控制流
      + controller 拥有三个方法

        + close
        + enqueue 通过该方法把数据添加到流里面
        + error

    + pull (controller) 可选

      + 这个方法，也是由开发人员定义的，当流的内部队列不满时，会重复调用这个方法，直到队列补满
      + 如果 pull() 返回一个 promise，那么它将不会再被调用，直到 promise 完成;如果 promise 失败，该流将会出现错误
      + 传递给此方法的 controller 参数是 ReadableStreamDefaultController 或 ReadableByteStreamController，具体取决于 type 属性的值
      + 由于更多的块被获取，这个方法可以被开发人员用来控制流

    + cancel (reason) 可选

      + 如果应用程序表示该流将被取消（例如，调用了 ReadableStream.cancel()，则将调用此方法，该方法也由开发人员定义
      + 该方法应该做任何必要的事情来释放对流的访问
      + 如果这个过程是异步的，它可以返回一个 promise，表明成功或失败
      + 原因参数包含一个 DOMString，它描述了流被取消的原因

    + type 可选

      + 该属性控制正在处理的可读类型的流
      + 如果它包含一个设置为 bytes 的值，则传递的控制器对象将是一个 ReadableByteStreamController，能够处理 BYOB（带你自己的缓冲区）/字节流
      + 如果未包含，则传递的控制器将为 ReadableStreamDefaultController

    + autoAllocateChunkSize 可选

      + 对于字节流，开发人员可以使用正整数值设置 autoAllocateChunkSize 以打开流的自动分配功能
      + 启用此功能后，流实现将自动分配一个具有给定整数大小的 ArrayBuffer，并调用底层源代码，就好像消费者正在使用 BYOB reader 一样

  + queuingStrategy 可选 一个可选择定义流的队列策略的对象。这需要两个参数：

    + highWaterMark 非负整数 - 这定义了在应用背压之前可以包含在内部队列中的块的总数

    + size(chunk) 包含参数 chunk 的方法——这表示每个分块使用的大小（以字节为单位）

+ 返回值 ReadableStream 对象的实例

## 示例

+ 示例

  ```js
  const stream = new ReadableStream({
    start(controller) {
      // 初始化操作，例如发起网络请求
      fetch("xxxxxxxxxxxx").then(response => {
        // 检查响应是否成功
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        // 将响应体转换为流
        const reader = response.body.getReader();

        return readFromStream(reader, controller);
      })
      .catch(error => {
        console.error('Fetch error:', error);
        controller.error(error);
      });
    },
    pull(controller) {
      // 流的内部队列不满时调用
      // 这里可以放置逻辑以决定是否需要从源获取更多数据
    }
  });

  // 辅助函数，用于递归读取流中的数据
  function readFromStream(reader, controller) {
    reader.read().then(({ value, done }) => {
      if (done) {
        controller.close(); // 没有更多数据，关闭流
        return;
      }
      controller.enqueue(value); // 将数据块添加到流中
      return readFromStream(reader, controller); // 递归读取下一个数据块
    });
  }

  // 使用 stream
  const reader = stream.getReader();
  readStreamData(reader);
  function readStreamData(reader) {
    // 读取数据并处理
    reader.read().then(({ value, done }) => {
      if (done) {
        console.log('Stream has ended');
        return;
      }
      // 处理数据 value
      console.log('Stream data chunk:', value);
      // 递归读取下一个数据块
      readStreamData(reader);
    }).catch(error => {
      console.error('Error reading stream:', error);
    });
  }
  ```
